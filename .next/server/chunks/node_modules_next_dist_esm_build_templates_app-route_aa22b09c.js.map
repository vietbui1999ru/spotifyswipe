{"version":3,"sources":["../../../node_modules/next/dist/esm/build/templates/app-route.js","../../../src/server/api/routers/post.ts","../../../node_modules/superjson/src/is.ts","../../../node_modules/superjson/src/plainer.ts","../../../node_modules/superjson/src/class-registry.ts","../../../node_modules/superjson/src/transformer.ts","../../../node_modules/superjson/src/util.ts","../../../node_modules/superjson/src/pathstringifier.ts","../../../node_modules/superjson/src/double-indexed-kv.ts","../../../node_modules/next/src/build/templates/app-route.ts","../../../node_modules/superjson/src/index.ts","../../../node_modules/superjson/src/registry.ts","../../../node_modules/superjson/src/custom-transformer-registry.ts","../../../node_modules/superjson/src/accessDeep.ts","../../../node_modules/copy-anything/dist/index.js","../../../node_modules/is-what/dist/getType.js","../../../node_modules/is-what/dist/isArray.js","../../../src/app/api/trpc/%5Btrpc%5D/route.ts","../../../node_modules/%40trpc/server/src/observable/observable.ts","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/error/formatter.ts","../../../node_modules/is-what/dist/isPlainObject.js","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/utils.ts","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/http/parseConnectionParams.ts","../../../src/server/api/root.ts","../../../node_modules/%40trpc/server/src/adapters/fetch/fetchRequestHandler.ts","../../../src/server/api/trpc.ts","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/middleware.ts","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/error/TRPCError.ts","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/createProxy.ts","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/http/contentType.ts","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/transformer.ts","../../../node_modules/%40trpc/server/src/vendor/standard-schema-v1/error.ts","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/http/getHTTPStatusCode.ts","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/rpc/codes.ts","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/parser.ts","../../../node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/objectWithoutPropertiesLoose.js","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/router.ts","../../../node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/objectWithoutProperties.js","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/procedureBuilder.ts","../../../node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/typeof.js","../../../node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/toPrimitive.js","../../../node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/toPropertyKey.js","../../../node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/defineProperty.js","../../../node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/objectSpread2.js","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/http/abortError.ts","../../../node_modules/%40trpc/server/src/vendor/is-plain-object.ts","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/error/getErrorShape.ts","../../../node_modules/%40trpc/server/src/vendor/unpromise/unpromise.ts","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/rootConfig.ts","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/initTRPC.ts","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/stream/tracked.ts","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/stream/utils/disposable.ts","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/stream/utils/timerResource.ts","../../../node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/usingCtx.js","../../../node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/OverloadYield.js","../../../node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/awaitAsyncGenerator.js","../../../node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/wrapAsyncGenerator.js","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/stream/utils/asyncIterable.ts","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/stream/utils/createDeferred.ts","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/stream/utils/mergeAsyncIterables.ts","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/stream/utils/readableStreamFrom.ts","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/stream/utils/withPing.ts","../../../node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/asyncIterator.js","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/stream/jsonl.ts","../../../node_modules/node_modules/.pnpm/%40oxc-project%2Bruntime%400.72.2/node_modules/%40oxc-project/runtime/src/helpers/asyncGeneratorDelegate.js","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/stream/sse.ts","../../../node_modules/%40trpc/server/src/unstable-core-do-not-import/http/resolveResponse.ts"],"sourcesContent":["import { AppRouteRouteModule } from \"next/dist/esm/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/esm/server/lib/patch-fetch\";\nimport { addRequestMeta, getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { setManifestsSingleton } from \"next/dist/esm/server/app-render/manifests-singleton\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { NextRequestAdapter, signalFromNodeResponse } from \"next/dist/esm/server/web/spec-extension/adapters/next-request\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { sendResponse } from \"next/dist/esm/server/send-response\";\nimport { fromNodeOutgoingHttpHeaders, toNodeOutgoingHttpHeaders } from \"next/dist/esm/server/web/utils\";\nimport { getCacheControlHeader } from \"next/dist/esm/server/lib/cache-control\";\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { CachedRouteKind } from \"next/dist/esm/server/response-cache\";\nimport * as userland from \"INNER_APP_ROUTE\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/trpc/[trpc]/route\",\n        pathname: \"/api/trpc/[trpc]\",\n        filename: \"route\",\n        bundlePath: \"\"\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n    resolvedPagePath: \"[project]/src/app/api/trpc/[trpc]/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\nexport async function handler(req, res, ctx) {\n    if (routeModule.isDev) {\n        addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\n    }\n    let srcPage = \"/api/trpc/[trpc]/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, parsedUrl, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname, clientReferenceManifest, serverActionsManifest } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    const render404 = async ()=>{\n        // TODO: should route-module itself handle rendering the 404\n        if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n            await routerServerContext.render404(req, res, parsedUrl, false);\n        } else {\n            res.end('This page could not be found');\n        }\n        return null;\n    };\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                if (nextConfig.experimental.adapterPath) {\n                    return await render404();\n                }\n                throw new NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isStaticGeneration = isIsr && !supportsDynamicResponse;\n    // Before rendering (which initializes component tree modules), we have to\n    // set the reference manifests to our global store so Server Action's\n    // encryption util can access to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        setManifestsSingleton({\n            page: srcPage,\n            clientReferenceManifest,\n            serverActionsManifest\n        });\n    }\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            cacheComponents: Boolean(nextConfig.cacheComponents),\n            supportsDynamicResponse,\n            incrementalCache: getRequestMeta(req, 'incrementalCache'),\n            cacheLifeProfiles: nextConfig.cacheLife,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext, silenceLog)=>routeModule.onRequestError(req, error, errorContext, silenceLog, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new NodeNextRequest(req);\n    const nodeNextRes = new NodeNextResponse(res);\n    const nextReq = NextRequestAdapter.fromNodeNextRequest(nodeNextReq, signalFromNodeResponse(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${srcPage}`);\n                }\n            });\n        };\n        const isMinimalMode = Boolean(process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode'));\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!isMinimalMode && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = toNodeOutgoingHttpHeaders(response.headers);\n                        if (cacheTags) {\n                            headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await sendResponse(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        const silenceLog = false;\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason({\n                                isStaticGeneration,\n                                isOnDemandRevalidate\n                            })\n                        }, silenceLog, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil,\n                isMinimalMode\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!isMinimalMode) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers);\n            if (!(isMinimalMode && isIsr)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(nodeNextReq, nodeNextRes, // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n            new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${srcPage}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof NoFallbackError)) {\n            const silenceLog = false;\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                    isStaticGeneration,\n                    isOnDemandRevalidate\n                })\n            }, silenceLog, routerServerContext);\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await sendResponse(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n","import { z } from \"zod\";\n\nimport {\n  createTRPCRouter,\n  protectedProcedure,\n  publicProcedure,\n} from \"~/server/api/trpc\";\n\nexport const postRouter = createTRPCRouter({\n  hello: publicProcedure\n    .input(z.object({ text: z.string() }))\n    .query(({ input }) => {\n      return {\n        greeting: `Hello ${input.text}`,\n      };\n    }),\n\n  create: protectedProcedure\n    .input(z.object({ name: z.string().min(1) }))\n    .mutation(async ({ ctx, input }) => {\n      return ctx.db.post.create({\n        data: {\n          name: input.name,\n          createdBy: { connect: { id: ctx.session.user.id } },\n        },\n      });\n    }),\n\n  getLatest: protectedProcedure.query(async ({ ctx }) => {\n    const post = await ctx.db.post.findFirst({\n      orderBy: { createdAt: \"desc\" },\n      where: { createdBy: { id: ctx.session.user.id } },\n    });\n\n    return post ?? null;\n  }),\n\n  getSecretMessage: protectedProcedure.query(() => {\n    return \"you can now see this secret message!\";\n  }),\n});\n","unable to read source [project]/node_modules/superjson/src/is.ts","unable to read source [project]/node_modules/superjson/src/plainer.ts","unable to read source [project]/node_modules/superjson/src/class-registry.ts","unable to read source [project]/node_modules/superjson/src/transformer.ts","unable to read source [project]/node_modules/superjson/src/util.ts","unable to read source [project]/node_modules/superjson/src/pathstringifier.ts","unable to read source [project]/node_modules/superjson/src/double-indexed-kv.ts","import {\n  AppRouteRouteModule,\n  type AppRouteRouteHandlerContext,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\nimport { addRequestMeta, getRequestMeta } from '../../server/request-meta'\nimport { getTracer, type Span, SpanKind } from '../../server/lib/trace/tracer'\nimport { setManifestsSingleton } from '../../server/app-render/manifests-singleton'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport {\n  NextRequestAdapter,\n  signalFromNodeResponse,\n} from '../../server/web/spec-extension/adapters/next-request'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { sendResponse } from '../../server/send-response'\nimport {\n  fromNodeOutgoingHttpHeaders,\n  toNodeOutgoingHttpHeaders,\n} from '../../server/web/utils'\nimport { getCacheControlHeader } from '../../server/lib/cache-control'\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\nimport {\n  CachedRouteKind,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil: (prom: Promise<void>) => void\n  }\n) {\n  if (routeModule.isDev) {\n    addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint())\n  }\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    params,\n    nextConfig,\n    parsedUrl,\n    isDraftMode,\n    prerenderManifest,\n    routerServerContext,\n    isOnDemandRevalidate,\n    revalidateOnlyGenerated,\n    resolvedPathname,\n    clientReferenceManifest,\n    serverActionsManifest,\n  } = prepareResult\n\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let isIsr = Boolean(\n    prerenderManifest.dynamicRoutes[normalizedSrcPage] ||\n      prerenderManifest.routes[resolvedPathname]\n  )\n\n  const render404 = async () => {\n    // TODO: should route-module itself handle rendering the 404\n    if (routerServerContext?.render404) {\n      await routerServerContext.render404(req, res, parsedUrl, false)\n    } else {\n      res.end('This page could not be found')\n    }\n    return null\n  }\n\n  if (isIsr && !isDraftMode) {\n    const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname])\n    const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n\n    if (prerenderInfo) {\n      if (prerenderInfo.fallback === false && !isPrerendered) {\n        if (nextConfig.experimental.adapterPath) {\n          return await render404()\n        }\n        throw new NoFallbackError()\n      }\n    }\n  }\n\n  let cacheKey: string | null = null\n\n  if (isIsr && !routeModule.isDev && !isDraftMode) {\n    cacheKey = resolvedPathname\n    // ensure /index and / is normalized to one key\n    cacheKey = cacheKey === '/index' ? '/' : cacheKey\n  }\n\n  const supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr\n\n  // This is a revalidation request if the request is for a static\n  // page and it is not being resumed from a postponed render and\n  // it is not a dynamic RSC request then it is a revalidation\n  // request.\n  const isStaticGeneration = isIsr && !supportsDynamicResponse\n\n  // Before rendering (which initializes component tree modules), we have to\n  // set the reference manifests to our global store so Server Action's\n  // encryption util can access to them at the top level of the page module.\n  if (serverActionsManifest && clientReferenceManifest) {\n    setManifestsSingleton({\n      page: srcPage,\n      clientReferenceManifest,\n      serverActionsManifest,\n    })\n  }\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  const context: AppRouteRouteHandlerContext = {\n    params,\n    prerenderManifest,\n    renderOpts: {\n      experimental: {\n        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n      },\n      cacheComponents: Boolean(nextConfig.cacheComponents),\n      supportsDynamicResponse,\n      incrementalCache: getRequestMeta(req, 'incrementalCache'),\n      cacheLifeProfiles: nextConfig.cacheLife,\n      waitUntil: ctx.waitUntil,\n      onClose: (cb) => {\n        res.on('close', cb)\n      },\n      onAfterTaskError: undefined,\n      onInstrumentationRequestError: (\n        error,\n        _request,\n        errorContext,\n        silenceLog\n      ) =>\n        routeModule.onRequestError(\n          req,\n          error,\n          errorContext,\n          silenceLog,\n          routerServerContext\n        ),\n    },\n    sharedContext: {\n      buildId,\n    },\n  }\n  const nodeNextReq = new NodeNextRequest(req)\n  const nodeNextRes = new NodeNextResponse(res)\n\n  const nextReq = NextRequestAdapter.fromNodeNextRequest(\n    nodeNextReq,\n    signalFromNodeResponse(res)\n  )\n\n  try {\n    const invokeRouteModule = async (span?: Span) => {\n      return routeModule.handle(nextReq, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${srcPage}`)\n        }\n      })\n    }\n    const isMinimalMode = Boolean(\n      process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode')\n    )\n\n    const handleResponse = async (currentSpan?: Span) => {\n      const responseGenerator: ResponseGenerator = async ({\n        previousCacheEntry,\n      }) => {\n        try {\n          if (\n            !isMinimalMode &&\n            isOnDemandRevalidate &&\n            revalidateOnlyGenerated &&\n            !previousCacheEntry\n          ) {\n            res.statusCode = 404\n            // on-demand revalidate always sets this header\n            res.setHeader('x-nextjs-cache', 'REVALIDATED')\n            res.end('This page could not be found')\n            return null\n          }\n\n          const response = await invokeRouteModule(currentSpan)\n\n          ;(req as any).fetchMetrics = (context.renderOpts as any).fetchMetrics\n          let pendingWaitUntil = context.renderOpts.pendingWaitUntil\n\n          // Attempt using provided waitUntil if available\n          // if it's not we fallback to sendResponse's handling\n          if (pendingWaitUntil) {\n            if (ctx.waitUntil) {\n              ctx.waitUntil(pendingWaitUntil)\n              pendingWaitUntil = undefined\n            }\n          }\n          const cacheTags = context.renderOpts.collectedTags\n\n          // If the request is for a static response, we can cache it so long\n          // as it's not edge.\n          if (isIsr) {\n            const blob = await response.blob()\n\n            // Copy the headers from the response.\n            const headers = toNodeOutgoingHttpHeaders(response.headers)\n\n            if (cacheTags) {\n              headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n            }\n\n            if (!headers['content-type'] && blob.type) {\n              headers['content-type'] = blob.type\n            }\n\n            const revalidate =\n              typeof context.renderOpts.collectedRevalidate === 'undefined' ||\n              context.renderOpts.collectedRevalidate >= INFINITE_CACHE\n                ? false\n                : context.renderOpts.collectedRevalidate\n\n            const expire =\n              typeof context.renderOpts.collectedExpire === 'undefined' ||\n              context.renderOpts.collectedExpire >= INFINITE_CACHE\n                ? undefined\n                : context.renderOpts.collectedExpire\n\n            // Create the cache entry for the response.\n            const cacheEntry: ResponseCacheEntry = {\n              value: {\n                kind: CachedRouteKind.APP_ROUTE,\n                status: response.status,\n                body: Buffer.from(await blob.arrayBuffer()),\n                headers,\n              },\n              cacheControl: { revalidate, expire },\n            }\n\n            return cacheEntry\n          } else {\n            // send response without caching if not ISR\n            await sendResponse(\n              nodeNextReq,\n              nodeNextRes,\n              response,\n              context.renderOpts.pendingWaitUntil\n            )\n            return null\n          }\n        } catch (err) {\n          // if this is a background revalidate we need to report\n          // the request error here as it won't be bubbled\n          if (previousCacheEntry?.isStale) {\n            const silenceLog = false\n            await routeModule.onRequestError(\n              req,\n              err,\n              {\n                routerKind: 'App Router',\n                routePath: srcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                  isStaticGeneration,\n                  isOnDemandRevalidate,\n                }),\n              },\n              silenceLog,\n              routerServerContext\n            )\n          }\n          throw err\n        }\n      }\n\n      const cacheEntry = await routeModule.handleResponse({\n        req,\n        nextConfig,\n        cacheKey,\n        routeKind: RouteKind.APP_ROUTE,\n        isFallback: false,\n        prerenderManifest,\n        isRoutePPREnabled: false,\n        isOnDemandRevalidate,\n        revalidateOnlyGenerated,\n        responseGenerator,\n        waitUntil: ctx.waitUntil,\n        isMinimalMode,\n      })\n\n      // we don't create a cacheEntry for ISR\n      if (!isIsr) {\n        return null\n      }\n\n      if (cacheEntry?.value?.kind !== CachedRouteKind.APP_ROUTE) {\n        throw new Error(\n          `Invariant: app-route received invalid cache entry ${cacheEntry?.value?.kind}`\n        )\n      }\n\n      if (!isMinimalMode) {\n        res.setHeader(\n          'x-nextjs-cache',\n          isOnDemandRevalidate\n            ? 'REVALIDATED'\n            : cacheEntry.isMiss\n              ? 'MISS'\n              : cacheEntry.isStale\n                ? 'STALE'\n                : 'HIT'\n        )\n      }\n\n      // Draft mode should never be cached\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers)\n\n      if (!(isMinimalMode && isIsr)) {\n        headers.delete(NEXT_CACHE_TAGS_HEADER)\n      }\n\n      // If cache control is already set on the response we don't\n      // override it to allow users to customize it via next.config\n      if (\n        cacheEntry.cacheControl &&\n        !res.getHeader('Cache-Control') &&\n        !headers.get('Cache-Control')\n      ) {\n        headers.set(\n          'Cache-Control',\n          getCacheControlHeader(cacheEntry.cacheControl)\n        )\n      }\n\n      await sendResponse(\n        nodeNextReq,\n        nodeNextRes,\n        // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n        new Response(cacheEntry.value.body, {\n          headers,\n          status: cacheEntry.value.status || 200,\n        })\n      )\n      return null\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${srcPage}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    if (!(err instanceof NoFallbackError)) {\n      const silenceLog = false\n      await routeModule.onRequestError(\n        req,\n        err,\n        {\n          routerKind: 'App Router',\n          routePath: normalizedSrcPage,\n          routeType: 'route',\n          revalidateReason: getRevalidateReason({\n            isStaticGeneration,\n            isOnDemandRevalidate,\n          }),\n        },\n        silenceLog,\n        routerServerContext\n      )\n    }\n\n    // rethrow so that we can handle serving error page\n\n    // If this is during static generation, throw the error again.\n    if (isIsr) throw err\n\n    // Otherwise, send a 500 response.\n    await sendResponse(\n      nodeNextReq,\n      nodeNextRes,\n      new Response(null, { status: 500 })\n    )\n    return null\n  }\n}\n","unable to read source [project]/node_modules/superjson/src/index.ts","unable to read source [project]/node_modules/superjson/src/registry.ts","unable to read source [project]/node_modules/superjson/src/custom-transformer-registry.ts","unable to read source [project]/node_modules/superjson/src/accessDeep.ts","import { isArray, isPlainObject } from 'is-what';\nfunction assignProp(carry, key, newVal, originalObject, includeNonenumerable) {\n    const propType = {}.propertyIsEnumerable.call(originalObject, key)\n        ? 'enumerable'\n        : 'nonenumerable';\n    if (propType === 'enumerable')\n        carry[key] = newVal;\n    if (includeNonenumerable && propType === 'nonenumerable') {\n        Object.defineProperty(carry, key, {\n            value: newVal,\n            enumerable: false,\n            writable: true,\n            configurable: true,\n        });\n    }\n}\n/**\n * Copy (clone) an object and all its props recursively to get rid of any prop referenced of the\n * original object. Arrays are also cloned, however objects inside arrays are still linked.\n *\n * @param target Target can be anything\n * @param [options={}] See type {@link Options} for more details.\n *\n *   - `{ props: ['key1'] }` will only copy the `key1` property. When using this you will need to cast\n *       the return type manually (in order to keep the TS implementation in here simple I didn't\n *       built a complex auto resolved type for those few cases people want to use this option)\n *   - `{ nonenumerable: true }` will copy all non-enumerable properties. Default is `{}`\n *\n * @returns The target with replaced values\n */\nexport function copy(target, options = {}) {\n    if (isArray(target)) {\n        return target.map((item) => copy(item, options));\n    }\n    if (!isPlainObject(target)) {\n        return target;\n    }\n    const props = Object.getOwnPropertyNames(target);\n    const symbols = Object.getOwnPropertySymbols(target);\n    return [...props, ...symbols].reduce((carry, key) => {\n        // Skip __proto__ properties to prevent prototype pollution\n        if (key === '__proto__')\n            return carry;\n        if (isArray(options.props) && !options.props.includes(key)) {\n            return carry;\n        }\n        const val = target[key];\n        const newVal = copy(val, options);\n        assignProp(carry, key, newVal, target, options.nonenumerable);\n        return carry;\n    }, {});\n}\n","/** Returns the object type of the given payload */\nexport function getType(payload) {\n    return Object.prototype.toString.call(payload).slice(8, -1);\n}\n","import { getType } from './getType.js';\n/** Returns whether the payload is an array */\nexport function isArray(payload) {\n    return getType(payload) === 'Array';\n}\n","import { fetchRequestHandler } from \"@trpc/server/adapters/fetch\";\nimport { type NextRequest } from \"next/server\";\n\nimport { env } from \"~/env\";\nimport { appRouter } from \"~/server/api/root\";\nimport { createTRPCContext } from \"~/server/api/trpc\";\n\n/**\n * This wraps the `createTRPCContext` helper and provides the required context for the tRPC API when\n * handling a HTTP request (e.g. when you make requests from Client Components).\n */\nconst createContext = async (req: NextRequest) => {\n  return createTRPCContext({\n    headers: req.headers,\n  });\n};\n\nconst handler = (req: NextRequest) =>\n  fetchRequestHandler({\n    endpoint: \"/api/trpc\",\n    req,\n    router: appRouter,\n    createContext: () => createContext(req),\n    onError:\n      env.NODE_ENV === \"development\"\n        ? ({ path, error }) => {\n            console.error(\n              `‚ùå tRPC failed on ${path ?? \"<no-path>\"}: ${error.message}`\n            );\n          }\n        : undefined,\n  });\n\nexport { handler as GET, handler as POST };\n","import type { Result } from '../unstable-core-do-not-import';\nimport type {\n  Observable,\n  Observer,\n  OperatorFunction,\n  TeardownLogic,\n  UnaryFunction,\n  Unsubscribable,\n} from './types';\n\n/** @public */\nexport type inferObservableValue<TObservable> =\n  TObservable extends Observable<infer TValue, unknown> ? TValue : never;\n\n/** @public */\nexport function isObservable(x: unknown): x is Observable<unknown, unknown> {\n  return typeof x === 'object' && x !== null && 'subscribe' in x;\n}\n\n/** @public */\nexport function observable<TValue, TError = unknown>(\n  subscribe: (observer: Observer<TValue, TError>) => TeardownLogic,\n): Observable<TValue, TError> {\n  const self: Observable<TValue, TError> = {\n    subscribe(observer) {\n      let teardownRef: TeardownLogic | null = null;\n      let isDone = false;\n      let unsubscribed = false;\n      let teardownImmediately = false;\n      function unsubscribe() {\n        if (teardownRef === null) {\n          teardownImmediately = true;\n          return;\n        }\n        if (unsubscribed) {\n          return;\n        }\n        unsubscribed = true;\n\n        if (typeof teardownRef === 'function') {\n          teardownRef();\n        } else if (teardownRef) {\n          teardownRef.unsubscribe();\n        }\n      }\n      teardownRef = subscribe({\n        next(value) {\n          if (isDone) {\n            return;\n          }\n          observer.next?.(value);\n        },\n        error(err) {\n          if (isDone) {\n            return;\n          }\n          isDone = true;\n          observer.error?.(err);\n          unsubscribe();\n        },\n        complete() {\n          if (isDone) {\n            return;\n          }\n          isDone = true;\n          observer.complete?.();\n          unsubscribe();\n        },\n      });\n      if (teardownImmediately) {\n        unsubscribe();\n      }\n      return {\n        unsubscribe,\n      };\n    },\n    pipe(\n      ...operations: OperatorFunction<any, any, any, any>[]\n    ): Observable<any, any> {\n      return operations.reduce(pipeReducer, self);\n    },\n  };\n  return self;\n}\n\nfunction pipeReducer(prev: any, fn: UnaryFunction<any, any>) {\n  return fn(prev);\n}\n\n/** @internal */\nexport function observableToPromise<TValue>(\n  observable: Observable<TValue, unknown>,\n) {\n  const ac = new AbortController();\n  const promise = new Promise<TValue>((resolve, reject) => {\n    let isDone = false;\n    function onDone() {\n      if (isDone) {\n        return;\n      }\n      isDone = true;\n      obs$.unsubscribe();\n    }\n    ac.signal.addEventListener('abort', () => {\n      reject(ac.signal.reason);\n    });\n    const obs$ = observable.subscribe({\n      next(data) {\n        isDone = true;\n        resolve(data);\n        onDone();\n      },\n      error(data) {\n        reject(data);\n      },\n      complete() {\n        ac.abort();\n        onDone();\n      },\n    });\n  });\n  return promise;\n}\n\n/**\n * @internal\n */\nfunction observableToReadableStream<TValue>(\n  observable: Observable<TValue, unknown>,\n  signal: AbortSignal,\n): ReadableStream<Result<TValue>> {\n  let unsub: Unsubscribable | null = null;\n\n  const onAbort = () => {\n    unsub?.unsubscribe();\n    unsub = null;\n    signal.removeEventListener('abort', onAbort);\n  };\n\n  return new ReadableStream<Result<TValue>>({\n    start(controller) {\n      unsub = observable.subscribe({\n        next(data) {\n          controller.enqueue({ ok: true, value: data });\n        },\n        error(error) {\n          controller.enqueue({ ok: false, error });\n          controller.close();\n        },\n        complete() {\n          controller.close();\n        },\n      });\n\n      if (signal.aborted) {\n        onAbort();\n      } else {\n        signal.addEventListener('abort', onAbort, { once: true });\n      }\n    },\n    cancel() {\n      onAbort();\n    },\n  });\n}\n\n/** @internal */\nexport function observableToAsyncIterable<TValue>(\n  observable: Observable<TValue, unknown>,\n  signal: AbortSignal,\n): AsyncIterable<TValue> {\n  const stream = observableToReadableStream(observable, signal);\n\n  const reader = stream.getReader();\n  const iterator: AsyncIterator<TValue> = {\n    async next() {\n      const value = await reader.read();\n      if (value.done) {\n        return {\n          value: undefined,\n          done: true,\n        };\n      }\n      const { value: result } = value;\n      if (!result.ok) {\n        throw result.error;\n      }\n      return {\n        value: result.value,\n        done: false,\n      };\n    },\n    async return() {\n      await reader.cancel();\n      return {\n        value: undefined,\n        done: true,\n      };\n    },\n  };\n  return {\n    [Symbol.asyncIterator]() {\n      return iterator;\n    },\n  };\n}\n","import type { ProcedureType } from '../procedure';\nimport type {\n  TRPC_ERROR_CODE_KEY,\n  TRPC_ERROR_CODE_NUMBER,\n  TRPCErrorShape,\n} from '../rpc';\nimport type { TRPCError } from './TRPCError';\n\n/**\n * @internal\n */\nexport type ErrorFormatter<TContext, TShape extends TRPCErrorShape> = (opts: {\n  error: TRPCError;\n  type: ProcedureType | 'unknown';\n  path: string | undefined;\n  input: unknown;\n  ctx: TContext | undefined;\n  shape: DefaultErrorShape;\n}) => TShape;\n\n/**\n * @internal\n */\nexport type DefaultErrorData = {\n  code: TRPC_ERROR_CODE_KEY;\n  httpStatus: number;\n  /**\n   * Path to the procedure that threw the error\n   */\n  path?: string;\n  /**\n   * Stack trace of the error (only in development)\n   */\n  stack?: string;\n};\n\n/**\n * @internal\n */\nexport interface DefaultErrorShape extends TRPCErrorShape<DefaultErrorData> {\n  message: string;\n  code: TRPC_ERROR_CODE_NUMBER;\n}\n\nexport const defaultFormatter: ErrorFormatter<any, any> = ({ shape }) => {\n  return shape;\n};\n","import { getType } from './getType.js';\n/**\n * Returns whether the payload is a plain JavaScript object (excluding special classes or objects\n * with other prototypes)\n */\nexport function isPlainObject(payload) {\n    if (getType(payload) !== 'Object')\n        return false;\n    const prototype = Object.getPrototypeOf(payload);\n    return !!prototype && prototype.constructor === Object && prototype === Object.prototype;\n}\n","/** @internal */\nexport type UnsetMarker = 'unsetMarker' & {\n  __brand: 'unsetMarker';\n};\n\n/**\n * Ensures there are no duplicate keys when building a procedure.\n * @internal\n */\nexport function mergeWithoutOverrides<TType extends Record<string, unknown>>(\n  obj1: TType,\n  ...objs: Partial<TType>[]\n): TType {\n  const newObj: TType = Object.assign(emptyObject(), obj1);\n\n  for (const overrides of objs) {\n    for (const key in overrides) {\n      if (key in newObj && newObj[key] !== overrides[key]) {\n        throw new Error(`Duplicate key ${key}`);\n      }\n      newObj[key as keyof TType] = overrides[key] as TType[keyof TType];\n    }\n  }\n  return newObj;\n}\n\n/**\n * Check that value is object\n * @internal\n */\nexport function isObject(value: unknown): value is Record<string, unknown> {\n  return !!value && !Array.isArray(value) && typeof value === 'object';\n}\n\ntype AnyFn = ((...args: any[]) => unknown) & Record<keyof any, unknown>;\nexport function isFunction(fn: unknown): fn is AnyFn {\n  return typeof fn === 'function';\n}\n\n/**\n * Create an object without inheriting anything from `Object.prototype`\n * @internal\n */\nexport function emptyObject<TObj extends Record<string, unknown>>(): TObj {\n  return Object.create(null);\n}\n\nconst asyncIteratorsSupported =\n  typeof Symbol === 'function' && !!Symbol.asyncIterator;\n\nexport function isAsyncIterable<TValue>(\n  value: unknown,\n): value is AsyncIterable<TValue> {\n  return (\n    asyncIteratorsSupported && isObject(value) && Symbol.asyncIterator in value\n  );\n}\n\n/**\n * Run an IIFE\n */\nexport const run = <TValue>(fn: () => TValue): TValue => fn();\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noop(): void {}\n\nexport function identity<T>(it: T): T {\n  return it;\n}\n\n/**\n * Generic runtime assertion function. Throws, if the condition is not `true`.\n *\n * Can be used as a slightly less dangerous variant of type assertions. Code\n * mistakes would be revealed at runtime then (hopefully during testing).\n */\nexport function assert(\n  condition: boolean,\n  msg = 'no additional info',\n): asserts condition {\n  if (!condition) {\n    throw new Error(`AssertionError: ${msg}`);\n  }\n}\n\nexport function sleep(ms = 0): Promise<void> {\n  return new Promise<void>((res) => setTimeout(res, ms));\n}\n\n/**\n * Ponyfill for\n * [`AbortSignal.any`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/any_static).\n */\nexport function abortSignalsAnyPonyfill(signals: AbortSignal[]): AbortSignal {\n  if (typeof AbortSignal.any === 'function') {\n    return AbortSignal.any(signals);\n  }\n\n  const ac = new AbortController();\n\n  for (const signal of signals) {\n    if (signal.aborted) {\n      trigger();\n      break;\n    }\n    signal.addEventListener('abort', trigger, { once: true });\n  }\n\n  return ac.signal;\n\n  function trigger() {\n    ac.abort();\n    for (const signal of signals) {\n      signal.removeEventListener('abort', trigger);\n    }\n  }\n}\n","import { TRPCError } from '../error/TRPCError';\nimport { isObject } from '../utils';\nimport type { TRPCRequestInfo } from './types';\n\nexport function parseConnectionParamsFromUnknown(\n  parsed: unknown,\n): TRPCRequestInfo['connectionParams'] {\n  try {\n    if (parsed === null) {\n      return null;\n    }\n    if (!isObject(parsed)) {\n      throw new Error('Expected object');\n    }\n    const nonStringValues = Object.entries(parsed).filter(\n      ([_key, value]) => typeof value !== 'string',\n    );\n\n    if (nonStringValues.length > 0) {\n      throw new Error(\n        `Expected connectionParams to be string values. Got ${nonStringValues\n          .map(([key, value]) => `${key}: ${typeof value}`)\n          .join(', ')}`,\n      );\n    }\n    return parsed as Record<string, string>;\n  } catch (cause) {\n    throw new TRPCError({\n      code: 'PARSE_ERROR',\n      message: 'Invalid connection params shape',\n      cause,\n    });\n  }\n}\nexport function parseConnectionParamsFromString(\n  str: string,\n): TRPCRequestInfo['connectionParams'] {\n  let parsed: unknown;\n  try {\n    parsed = JSON.parse(str);\n  } catch (cause) {\n    throw new TRPCError({\n      code: 'PARSE_ERROR',\n      message: 'Not JSON-parsable query params',\n      cause,\n    });\n  }\n  return parseConnectionParamsFromUnknown(parsed);\n}\n","import { postRouter } from \"~/server/api/routers/post\";\nimport { createCallerFactory, createTRPCRouter } from \"~/server/api/trpc\";\n\n/**\n * This is the primary router for your server.\n *\n * All routers added in /api/routers should be manually added here.\n */\nexport const appRouter = createTRPCRouter({\n  post: postRouter,\n});\n\n// export type definition of API\nexport type AppRouter = typeof appRouter;\n\n/**\n * Create a server-side caller for the tRPC API.\n * @example\n * const trpc = createCaller(createContext);\n * const res = await trpc.post.all();\n *       ^? Post[]\n */\nexport const createCaller = createCallerFactory(appRouter);\n","/**\n * If you're making an adapter for tRPC and looking at this file for reference, you should import types and functions from `@trpc/server` and `@trpc/server/http`\n *\n * @example\n * ```ts\n * import type { AnyTRPCRouter } from '@trpc/server'\n * import type { HTTPBaseHandlerOptions } from '@trpc/server/http'\n * ```\n */\n// @trpc/server\n\nimport type { AnyRouter } from '../../@trpc/server';\nimport type { ResolveHTTPRequestOptionsContextFn } from '../../@trpc/server/http';\nimport { resolveResponse } from '../../@trpc/server/http';\nimport type { FetchHandlerRequestOptions } from './types';\n\nconst trimSlashes = (path: string): string => {\n  path = path.startsWith('/') ? path.slice(1) : path;\n  path = path.endsWith('/') ? path.slice(0, -1) : path;\n\n  return path;\n};\n\nexport async function fetchRequestHandler<TRouter extends AnyRouter>(\n  opts: FetchHandlerRequestOptions<TRouter>,\n): Promise<Response> {\n  const resHeaders = new Headers();\n\n  const createContext: ResolveHTTPRequestOptionsContextFn<TRouter> = async (\n    innerOpts,\n  ) => {\n    return opts.createContext?.({ req: opts.req, resHeaders, ...innerOpts });\n  };\n\n  const url = new URL(opts.req.url);\n\n  const pathname = trimSlashes(url.pathname);\n  const endpoint = trimSlashes(opts.endpoint);\n  const path = trimSlashes(pathname.slice(endpoint.length));\n\n  return await resolveResponse({\n    ...opts,\n    req: opts.req,\n    createContext,\n    path,\n    error: null,\n    onError(o) {\n      opts?.onError?.({ ...o, req: opts.req });\n    },\n    responseMeta(data) {\n      const meta = opts.responseMeta?.(data);\n\n      if (meta?.headers) {\n        if (meta.headers instanceof Headers) {\n          for (const [key, value] of meta.headers.entries()) {\n            resHeaders.append(key, value);\n          }\n        } else {\n          /**\n           * @deprecated, delete in v12\n           */\n          for (const [key, value] of Object.entries(meta.headers)) {\n            if (Array.isArray(value)) {\n              for (const v of value) {\n                resHeaders.append(key, v);\n              }\n            } else if (typeof value === 'string') {\n              resHeaders.set(key, value);\n            }\n          }\n        }\n      }\n\n      return {\n        headers: resHeaders,\n        status: meta?.status,\n      };\n    },\n  });\n}\n","/**\n * YOU PROBABLY DON'T NEED TO EDIT THIS FILE, UNLESS:\n * 1. You want to modify request context (see Part 1).\n * 2. You want to create a new middleware or type of procedure (see Part 3).\n *\n * TL;DR - This is where all the tRPC server stuff is created and plugged in. The pieces you will\n * need to use are documented accordingly near the end.\n */\n\nimport { initTRPC, TRPCError } from \"@trpc/server\";\nimport superjson from \"superjson\";\nimport { ZodError } from \"zod\";\n\nimport { auth } from \"~/server/auth\";\nimport { db } from \"~/server/db\";\n\n/**\n * 1. CONTEXT\n *\n * This section defines the \"contexts\" that are available in the backend API.\n *\n * These allow you to access things when processing a request, like the database, the session, etc.\n *\n * This helper generates the \"internals\" for a tRPC context. The API handler and RSC clients each\n * wrap this and provides the required context.\n *\n * @see https://trpc.io/docs/server/context\n */\nexport const createTRPCContext = async (opts: { headers: Headers }) => {\n  const session = await auth();\n\n  return {\n    db,\n    session,\n    ...opts,\n  };\n};\n\n/**\n * 2. INITIALIZATION\n *\n * This is where the tRPC API is initialized, connecting the context and transformer. We also parse\n * ZodErrors so that you get typesafety on the frontend if your procedure fails due to validation\n * errors on the backend.\n */\nconst t = initTRPC.context<typeof createTRPCContext>().create({\n  transformer: superjson,\n  errorFormatter({ shape, error }) {\n    return {\n      ...shape,\n      data: {\n        ...shape.data,\n        zodError:\n          error.cause instanceof ZodError ? error.cause.flatten() : null,\n      },\n    };\n  },\n});\n\n/**\n * Create a server-side caller.\n *\n * @see https://trpc.io/docs/server/server-side-calls\n */\nexport const createCallerFactory = t.createCallerFactory;\n\n/**\n * 3. ROUTER & PROCEDURE (THE IMPORTANT BIT)\n *\n * These are the pieces you use to build your tRPC API. You should import these a lot in the\n * \"/src/server/api/routers\" directory.\n */\n\n/**\n * This is how you create new routers and sub-routers in your tRPC API.\n *\n * @see https://trpc.io/docs/router\n */\nexport const createTRPCRouter = t.router;\n\n/**\n * Middleware for timing procedure execution and adding an artificial delay in development.\n *\n * You can remove this if you don't like it, but it can help catch unwanted waterfalls by simulating\n * network latency that would occur in production but not in local development.\n */\nconst timingMiddleware = t.middleware(async ({ next, path }) => {\n  const start = Date.now();\n\n  if (t._config.isDev) {\n    // artificial delay in dev\n    const waitMs = Math.floor(Math.random() * 400) + 100;\n    await new Promise((resolve) => setTimeout(resolve, waitMs));\n  }\n\n  const result = await next();\n\n  const end = Date.now();\n  console.log(`[TRPC] ${path} took ${end - start}ms to execute`);\n\n  return result;\n});\n\n/**\n * Public (unauthenticated) procedure\n *\n * This is the base piece you use to build new queries and mutations on your tRPC API. It does not\n * guarantee that a user querying is authorized, but you can still access user session data if they\n * are logged in.\n */\nexport const publicProcedure = t.procedure.use(timingMiddleware);\n\n/**\n * Protected (authenticated) procedure\n *\n * If you want a query or mutation to ONLY be accessible to logged in users, use this. It verifies\n * the session is valid and guarantees `ctx.session.user` is not null.\n *\n * @see https://trpc.io/docs/procedures\n */\nexport const protectedProcedure = t.procedure\n  .use(timingMiddleware)\n  .use(({ ctx, next }) => {\n    if (!ctx.session?.user) {\n      throw new TRPCError({ code: \"UNAUTHORIZED\" });\n    }\n    return next({\n      ctx: {\n        // infers the `session` as non-nullable\n        session: { ...ctx.session, user: ctx.session.user },\n      },\n    });\n  });\n","import { TRPCError } from './error/TRPCError';\nimport type { ParseFn } from './parser';\nimport type { ProcedureType } from './procedure';\nimport type { GetRawInputFn, Overwrite, Simplify } from './types';\nimport { isObject } from './utils';\n\n/** @internal */\nexport const middlewareMarker = 'middlewareMarker' as 'middlewareMarker' & {\n  __brand: 'middlewareMarker';\n};\ntype MiddlewareMarker = typeof middlewareMarker;\n\ninterface MiddlewareResultBase {\n  /**\n   * All middlewares should pass through their `next()`'s output.\n   * Requiring this marker makes sure that can't be forgotten at compile-time.\n   */\n  readonly marker: MiddlewareMarker;\n}\n\ninterface MiddlewareOKResult<_TContextOverride> extends MiddlewareResultBase {\n  ok: true;\n  data: unknown;\n  // this could be extended with `input`/`rawInput` later\n}\n\ninterface MiddlewareErrorResult<_TContextOverride>\n  extends MiddlewareResultBase {\n  ok: false;\n  error: TRPCError;\n}\n\n/**\n * @internal\n */\nexport type MiddlewareResult<_TContextOverride> =\n  | MiddlewareErrorResult<_TContextOverride>\n  | MiddlewareOKResult<_TContextOverride>;\n\n/**\n * @internal\n */\nexport interface MiddlewareBuilder<\n  TContext,\n  TMeta,\n  TContextOverrides,\n  TInputOut,\n> {\n  /**\n   * Create a new builder based on the current middleware builder\n   */\n  unstable_pipe<$ContextOverridesOut>(\n    fn:\n      | MiddlewareFunction<\n          TContext,\n          TMeta,\n          TContextOverrides,\n          $ContextOverridesOut,\n          TInputOut\n        >\n      | MiddlewareBuilder<\n          Overwrite<TContext, TContextOverrides>,\n          TMeta,\n          $ContextOverridesOut,\n          TInputOut\n        >,\n  ): MiddlewareBuilder<\n    TContext,\n    TMeta,\n    Overwrite<TContextOverrides, $ContextOverridesOut>,\n    TInputOut\n  >;\n\n  /**\n   * List of middlewares within this middleware builder\n   */\n  _middlewares: MiddlewareFunction<\n    TContext,\n    TMeta,\n    TContextOverrides,\n    object,\n    TInputOut\n  >[];\n}\n\n/**\n * @internal\n */\nexport type MiddlewareFunction<\n  TContext,\n  TMeta,\n  TContextOverridesIn,\n  $ContextOverridesOut,\n  TInputOut,\n> = {\n  (opts: {\n    ctx: Simplify<Overwrite<TContext, TContextOverridesIn>>;\n    type: ProcedureType;\n    path: string;\n    input: TInputOut;\n    getRawInput: GetRawInputFn;\n    meta: TMeta | undefined;\n    signal: AbortSignal | undefined;\n    next: {\n      (): Promise<MiddlewareResult<TContextOverridesIn>>;\n      <$ContextOverride>(opts: {\n        ctx?: $ContextOverride;\n        input?: unknown;\n      }): Promise<MiddlewareResult<$ContextOverride>>;\n      (opts: {\n        getRawInput: GetRawInputFn;\n      }): Promise<MiddlewareResult<TContextOverridesIn>>;\n    };\n  }): Promise<MiddlewareResult<$ContextOverridesOut>>;\n  _type?: string | undefined;\n};\n\nexport type AnyMiddlewareFunction = MiddlewareFunction<any, any, any, any, any>;\nexport type AnyMiddlewareBuilder = MiddlewareBuilder<any, any, any, any>;\n/**\n * @internal\n */\nexport function createMiddlewareFactory<\n  TContext,\n  TMeta,\n  TInputOut = unknown,\n>() {\n  function createMiddlewareInner(\n    middlewares: AnyMiddlewareFunction[],\n  ): AnyMiddlewareBuilder {\n    return {\n      _middlewares: middlewares,\n      unstable_pipe(middlewareBuilderOrFn) {\n        const pipedMiddleware =\n          '_middlewares' in middlewareBuilderOrFn\n            ? middlewareBuilderOrFn._middlewares\n            : [middlewareBuilderOrFn];\n\n        return createMiddlewareInner([...middlewares, ...pipedMiddleware]);\n      },\n    };\n  }\n\n  function createMiddleware<$ContextOverrides>(\n    fn: MiddlewareFunction<\n      TContext,\n      TMeta,\n      object,\n      $ContextOverrides,\n      TInputOut\n    >,\n  ): MiddlewareBuilder<TContext, TMeta, $ContextOverrides, TInputOut> {\n    return createMiddlewareInner([fn]);\n  }\n\n  return createMiddleware;\n}\n\n/**\n * Create a standalone middleware\n * @see https://trpc.io/docs/v11/server/middlewares#experimental-standalone-middlewares\n * @deprecated use `.concat()` instead\n */\nexport const experimental_standaloneMiddleware = <\n  TCtx extends {\n    ctx?: object;\n    meta?: object;\n    input?: unknown;\n  },\n>() => ({\n  create: createMiddlewareFactory<\n    TCtx extends { ctx: infer T extends object } ? T : any,\n    TCtx extends { meta: infer T extends object } ? T : object,\n    TCtx extends { input: infer T } ? T : unknown\n  >(),\n});\n\n/**\n * @internal\n * Please note, `trpc-openapi` uses this function.\n */\nexport function createInputMiddleware<TInput>(parse: ParseFn<TInput>) {\n  const inputMiddleware: AnyMiddlewareFunction =\n    async function inputValidatorMiddleware(opts) {\n      let parsedInput: ReturnType<typeof parse>;\n\n      const rawInput = await opts.getRawInput();\n      try {\n        parsedInput = await parse(rawInput);\n      } catch (cause) {\n        throw new TRPCError({\n          code: 'BAD_REQUEST',\n          cause,\n        });\n      }\n\n      // Multiple input parsers\n      const combinedInput =\n        isObject(opts.input) && isObject(parsedInput)\n          ? {\n              ...opts.input,\n              ...parsedInput,\n            }\n          : parsedInput;\n\n      return opts.next({ input: combinedInput });\n    };\n  inputMiddleware._type = 'input';\n  return inputMiddleware;\n}\n\n/**\n * @internal\n */\nexport function createOutputMiddleware<TOutput>(parse: ParseFn<TOutput>) {\n  const outputMiddleware: AnyMiddlewareFunction =\n    async function outputValidatorMiddleware({ next }) {\n      const result = await next();\n      if (!result.ok) {\n        // pass through failures without validating\n        return result;\n      }\n      try {\n        const data = await parse(result.data);\n        return {\n          ...result,\n          data,\n        };\n      } catch (cause) {\n        throw new TRPCError({\n          message: 'Output validation failed',\n          code: 'INTERNAL_SERVER_ERROR',\n          cause,\n        });\n      }\n    };\n  outputMiddleware._type = 'output';\n  return outputMiddleware;\n}\n","import type { TRPC_ERROR_CODE_KEY } from '../rpc/codes';\nimport { isObject } from '../utils';\n\nclass UnknownCauseError extends Error {\n  [key: string]: unknown;\n}\nexport function getCauseFromUnknown(cause: unknown): Error | undefined {\n  if (cause instanceof Error) {\n    return cause;\n  }\n\n  const type = typeof cause;\n  if (type === 'undefined' || type === 'function' || cause === null) {\n    return undefined;\n  }\n\n  // Primitive types just get wrapped in an error\n  if (type !== 'object') {\n    // eslint-disable-next-line @typescript-eslint/no-base-to-string\n    return new Error(String(cause));\n  }\n\n  // If it's an object, we'll create a synthetic error\n  if (isObject(cause)) {\n    return Object.assign(new UnknownCauseError(), cause);\n  }\n\n  return undefined;\n}\n\nexport function getTRPCErrorFromUnknown(cause: unknown): TRPCError {\n  if (cause instanceof TRPCError) {\n    return cause;\n  }\n  if (cause instanceof Error && cause.name === 'TRPCError') {\n    // https://github.com/trpc/trpc/pull/4848\n    return cause as TRPCError;\n  }\n\n  const trpcError = new TRPCError({\n    code: 'INTERNAL_SERVER_ERROR',\n    cause,\n  });\n\n  // Inherit stack from error\n  if (cause instanceof Error && cause.stack) {\n    trpcError.stack = cause.stack;\n  }\n\n  return trpcError;\n}\n\nexport class TRPCError extends Error {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore override doesn't work in all environments due to \"This member cannot have an 'override' modifier because it is not declared in the base class 'Error'\"\n  public override readonly cause?: Error;\n  public readonly code;\n\n  constructor(opts: {\n    message?: string;\n    code: TRPC_ERROR_CODE_KEY;\n    cause?: unknown;\n  }) {\n    const cause = getCauseFromUnknown(opts.cause);\n    const message = opts.message ?? cause?.message ?? opts.code;\n\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore https://github.com/tc39/proposal-error-cause\n    super(message, { cause });\n\n    this.code = opts.code;\n    this.name = 'TRPCError';\n    this.cause ??= cause;\n  }\n}\n","import { emptyObject } from './utils';\n\ninterface ProxyCallbackOptions {\n  path: readonly string[];\n  args: readonly unknown[];\n}\ntype ProxyCallback = (opts: ProxyCallbackOptions) => unknown;\n\nconst noop = () => {\n  // noop\n};\n\nconst freezeIfAvailable = (obj: object) => {\n  if (Object.freeze) {\n    Object.freeze(obj);\n  }\n};\n\nfunction createInnerProxy(\n  callback: ProxyCallback,\n  path: readonly string[],\n  memo: Record<string, unknown>,\n) {\n  const cacheKey = path.join('.');\n\n  memo[cacheKey] ??= new Proxy(noop, {\n    get(_obj, key) {\n      if (typeof key !== 'string' || key === 'then') {\n        // special case for if the proxy is accidentally treated\n        // like a PromiseLike (like in `Promise.resolve(proxy)`)\n        return undefined;\n      }\n      return createInnerProxy(callback, [...path, key], memo);\n    },\n    apply(_1, _2, args) {\n      const lastOfPath = path[path.length - 1];\n\n      let opts = { args, path };\n      // special handling for e.g. `trpc.hello.call(this, 'there')` and `trpc.hello.apply(this, ['there'])\n      if (lastOfPath === 'call') {\n        opts = {\n          args: args.length >= 2 ? [args[1]] : [],\n          path: path.slice(0, -1),\n        };\n      } else if (lastOfPath === 'apply') {\n        opts = {\n          args: args.length >= 2 ? args[1] : [],\n          path: path.slice(0, -1),\n        };\n      }\n      freezeIfAvailable(opts.args);\n      freezeIfAvailable(opts.path);\n      return callback(opts);\n    },\n  });\n\n  return memo[cacheKey];\n}\n\n/**\n * Creates a proxy that calls the callback with the path and arguments\n *\n * @internal\n */\nexport const createRecursiveProxy = <TFaux = unknown>(\n  callback: ProxyCallback,\n): TFaux => createInnerProxy(callback, [], emptyObject()) as TFaux;\n\n/**\n * Used in place of `new Proxy` where each handler will map 1 level deep to another value.\n *\n * @internal\n */\nexport const createFlatProxy = <TFaux>(\n  callback: (path: keyof TFaux) => any,\n): TFaux => {\n  return new Proxy(noop, {\n    get(_obj, name) {\n      if (name === 'then') {\n        // special case for if the proxy is accidentally treated\n        // like a PromiseLike (like in `Promise.resolve(proxy)`)\n        return undefined;\n      }\n      return callback(name as any);\n    },\n  }) as TFaux;\n};\n","import { TRPCError } from '../error/TRPCError';\nimport type { ProcedureType } from '../procedure';\nimport { getProcedureAtPath, type AnyRouter } from '../router';\nimport { emptyObject, isObject } from '../utils';\nimport { parseConnectionParamsFromString } from './parseConnectionParams';\nimport type { TRPCAcceptHeader, TRPCRequestInfo } from './types';\n\ntype GetRequestInfoOptions = {\n  path: string;\n  req: Request;\n  url: URL | null;\n  searchParams: URLSearchParams;\n  headers: Headers;\n  router: AnyRouter;\n};\n\ntype ContentTypeHandler = {\n  isMatch: (opts: Request) => boolean;\n  parse: (opts: GetRequestInfoOptions) => Promise<TRPCRequestInfo>;\n};\n\n/**\n * Memoize a function that takes no arguments\n * @internal\n */\nfunction memo<TReturn>(fn: () => Promise<TReturn>) {\n  let promise: Promise<TReturn> | null = null;\n  const sym = Symbol.for('@trpc/server/http/memo');\n  let value: TReturn | typeof sym = sym;\n  return {\n    /**\n     * Lazily read the value\n     */\n    read: async (): Promise<TReturn> => {\n      if (value !== sym) {\n        return value;\n      }\n\n      // dedupes promises and catches errors\n      promise ??= fn().catch((cause) => {\n        if (cause instanceof TRPCError) {\n          throw cause;\n        }\n        throw new TRPCError({\n          code: 'BAD_REQUEST',\n          message: cause instanceof Error ? cause.message : 'Invalid input',\n          cause,\n        });\n      });\n\n      value = await promise;\n      promise = null;\n\n      return value;\n    },\n    /**\n     * Get an already stored result\n     */\n    result: (): TReturn | undefined => {\n      return value !== sym ? value : undefined;\n    },\n  };\n}\n\nconst jsonContentTypeHandler: ContentTypeHandler = {\n  isMatch(req) {\n    return !!req.headers.get('content-type')?.startsWith('application/json');\n  },\n  async parse(opts) {\n    const { req } = opts;\n    const isBatchCall = opts.searchParams.get('batch') === '1';\n    const paths = isBatchCall ? opts.path.split(',') : [opts.path];\n\n    type InputRecord = Record<number, unknown>;\n    const getInputs = memo(async (): Promise<InputRecord> => {\n      let inputs: unknown = undefined;\n      if (req.method === 'GET') {\n        const queryInput = opts.searchParams.get('input');\n        if (queryInput) {\n          inputs = JSON.parse(queryInput);\n        }\n      } else {\n        inputs = await req.json();\n      }\n      if (inputs === undefined) {\n        return emptyObject();\n      }\n\n      if (!isBatchCall) {\n        const result: InputRecord = emptyObject();\n        result[0] =\n          opts.router._def._config.transformer.input.deserialize(inputs);\n        return result;\n      }\n\n      if (!isObject(inputs)) {\n        throw new TRPCError({\n          code: 'BAD_REQUEST',\n          message: '\"input\" needs to be an object when doing a batch call',\n        });\n      }\n      const acc: InputRecord = emptyObject();\n      for (const index of paths.keys()) {\n        const input = inputs[index];\n        if (input !== undefined) {\n          acc[index] =\n            opts.router._def._config.transformer.input.deserialize(input);\n        }\n      }\n\n      return acc;\n    });\n\n    const calls = await Promise.all(\n      paths.map(\n        async (path, index): Promise<TRPCRequestInfo['calls'][number]> => {\n          const procedure = await getProcedureAtPath(opts.router, path);\n          return {\n            path,\n            procedure,\n            getRawInput: async () => {\n              const inputs = await getInputs.read();\n              let input = inputs[index];\n\n              if (procedure?._def.type === 'subscription') {\n                const lastEventId =\n                  opts.headers.get('last-event-id') ??\n                  opts.searchParams.get('lastEventId') ??\n                  opts.searchParams.get('Last-Event-Id');\n\n                if (lastEventId) {\n                  if (isObject(input)) {\n                    input = {\n                      ...input,\n                      lastEventId: lastEventId,\n                    };\n                  } else {\n                    input ??= {\n                      lastEventId: lastEventId,\n                    };\n                  }\n                }\n              }\n              return input;\n            },\n            result: () => {\n              return getInputs.result()?.[index];\n            },\n          };\n        },\n      ),\n    );\n\n    const types = new Set(\n      calls.map((call) => call.procedure?._def.type).filter(Boolean),\n    );\n\n    /* istanbul ignore if -- @preserve */\n    if (types.size > 1) {\n      throw new TRPCError({\n        code: 'BAD_REQUEST',\n        message: `Cannot mix procedure types in call: ${Array.from(types).join(\n          ', ',\n        )}`,\n      });\n    }\n    const type: ProcedureType | 'unknown' =\n      types.values().next().value ?? 'unknown';\n\n    const connectionParamsStr = opts.searchParams.get('connectionParams');\n\n    const info: TRPCRequestInfo = {\n      isBatchCall,\n      accept: req.headers.get('trpc-accept') as TRPCAcceptHeader | null,\n      calls,\n      type,\n      connectionParams:\n        connectionParamsStr === null\n          ? null\n          : parseConnectionParamsFromString(connectionParamsStr),\n      signal: req.signal,\n      url: opts.url,\n    };\n    return info;\n  },\n};\n\nconst formDataContentTypeHandler: ContentTypeHandler = {\n  isMatch(req) {\n    return !!req.headers.get('content-type')?.startsWith('multipart/form-data');\n  },\n  async parse(opts) {\n    const { req } = opts;\n    if (req.method !== 'POST') {\n      throw new TRPCError({\n        code: 'METHOD_NOT_SUPPORTED',\n        message:\n          'Only POST requests are supported for multipart/form-data requests',\n      });\n    }\n    const getInputs = memo(async () => {\n      const fd = await req.formData();\n      return fd;\n    });\n    const procedure = await getProcedureAtPath(opts.router, opts.path);\n    return {\n      accept: null,\n      calls: [\n        {\n          path: opts.path,\n          getRawInput: getInputs.read,\n          result: getInputs.result,\n          procedure,\n        },\n      ],\n      isBatchCall: false,\n      type: 'mutation',\n      connectionParams: null,\n      signal: req.signal,\n      url: opts.url,\n    };\n  },\n};\n\nconst octetStreamContentTypeHandler: ContentTypeHandler = {\n  isMatch(req) {\n    return !!req.headers\n      .get('content-type')\n      ?.startsWith('application/octet-stream');\n  },\n  async parse(opts) {\n    const { req } = opts;\n    if (req.method !== 'POST') {\n      throw new TRPCError({\n        code: 'METHOD_NOT_SUPPORTED',\n        message:\n          'Only POST requests are supported for application/octet-stream requests',\n      });\n    }\n    const getInputs = memo(async () => {\n      return req.body;\n    });\n    return {\n      calls: [\n        {\n          path: opts.path,\n          getRawInput: getInputs.read,\n          result: getInputs.result,\n          procedure: await getProcedureAtPath(opts.router, opts.path),\n        },\n      ],\n      isBatchCall: false,\n      accept: null,\n      type: 'mutation',\n      connectionParams: null,\n      signal: req.signal,\n      url: opts.url,\n    };\n  },\n};\n\nconst handlers = [\n  jsonContentTypeHandler,\n  formDataContentTypeHandler,\n  octetStreamContentTypeHandler,\n];\n\nfunction getContentTypeHandler(req: Request): ContentTypeHandler {\n  const handler = handlers.find((handler) => handler.isMatch(req));\n  if (handler) {\n    return handler;\n  }\n\n  if (!handler && req.method === 'GET') {\n    // fallback to JSON for get requests so GET-requests can be opened in browser easily\n    return jsonContentTypeHandler;\n  }\n\n  throw new TRPCError({\n    code: 'UNSUPPORTED_MEDIA_TYPE',\n    message: req.headers.has('content-type')\n      ? `Unsupported content-type \"${req.headers.get('content-type')}`\n      : 'Missing content-type header',\n  });\n}\n\nexport async function getRequestInfo(\n  opts: GetRequestInfoOptions,\n): Promise<TRPCRequestInfo> {\n  const handler = getContentTypeHandler(opts.req);\n  return await handler.parse(opts);\n}\n","import type { AnyRootTypes, RootConfig } from './rootConfig';\nimport type { AnyRouter, inferRouterError } from './router';\nimport type {\n  TRPCResponse,\n  TRPCResponseMessage,\n  TRPCResultMessage,\n} from './rpc';\nimport { isObject } from './utils';\n\n/**\n * @public\n */\nexport interface DataTransformer {\n  serialize(object: any): any;\n  deserialize(object: any): any;\n}\n\ninterface InputDataTransformer extends DataTransformer {\n  /**\n   * This function runs **on the client** before sending the data to the server.\n   */\n  serialize(object: any): any;\n  /**\n   * This function runs **on the server** to transform the data before it is passed to the resolver\n   */\n  deserialize(object: any): any;\n}\n\ninterface OutputDataTransformer extends DataTransformer {\n  /**\n   * This function runs **on the server** before sending the data to the client.\n   */\n  serialize(object: any): any;\n  /**\n   * This function runs **only on the client** to transform the data sent from the server.\n   */\n  deserialize(object: any): any;\n}\n\n/**\n * @public\n */\nexport interface CombinedDataTransformer {\n  /**\n   * Specify how the data sent from the client to the server should be transformed.\n   */\n  input: InputDataTransformer;\n  /**\n   * Specify how the data sent from the server to the client should be transformed.\n   */\n  output: OutputDataTransformer;\n}\n\n/**\n * @public\n */\nexport type CombinedDataTransformerClient = {\n  input: Pick<CombinedDataTransformer['input'], 'serialize'>;\n  output: Pick<CombinedDataTransformer['output'], 'deserialize'>;\n};\n\n/**\n * @public\n */\nexport type DataTransformerOptions = CombinedDataTransformer | DataTransformer;\n\n/**\n * @internal\n */\nexport function getDataTransformer(\n  transformer: DataTransformerOptions,\n): CombinedDataTransformer {\n  if ('input' in transformer) {\n    return transformer;\n  }\n  return { input: transformer, output: transformer };\n}\n\n/**\n * @internal\n */\nexport const defaultTransformer: CombinedDataTransformer = {\n  input: { serialize: (obj) => obj, deserialize: (obj) => obj },\n  output: { serialize: (obj) => obj, deserialize: (obj) => obj },\n};\n\nfunction transformTRPCResponseItem<\n  TResponseItem extends TRPCResponse | TRPCResponseMessage,\n>(config: RootConfig<AnyRootTypes>, item: TResponseItem): TResponseItem {\n  if ('error' in item) {\n    return {\n      ...item,\n      error: config.transformer.output.serialize(item.error),\n    };\n  }\n\n  if ('data' in item.result) {\n    return {\n      ...item,\n      result: {\n        ...item.result,\n        data: config.transformer.output.serialize(item.result.data),\n      },\n    };\n  }\n\n  return item;\n}\n\n/**\n * Takes a unserialized `TRPCResponse` and serializes it with the router's transformers\n **/\nexport function transformTRPCResponse<\n  TResponse extends\n    | TRPCResponse\n    | TRPCResponse[]\n    | TRPCResponseMessage\n    | TRPCResponseMessage[],\n>(config: RootConfig<AnyRootTypes>, itemOrItems: TResponse) {\n  return Array.isArray(itemOrItems)\n    ? itemOrItems.map((item) => transformTRPCResponseItem(config, item))\n    : transformTRPCResponseItem(config, itemOrItems);\n}\n\n// FIXME:\n// - the generics here are probably unnecessary\n// - the RPC-spec could probably be simplified to combine HTTP + WS\n/** @internal */\nfunction transformResultInner<TRouter extends AnyRouter, TOutput>(\n  response:\n    | TRPCResponse<TOutput, inferRouterError<TRouter>>\n    | TRPCResponseMessage<TOutput, inferRouterError<TRouter>>,\n  transformer: DataTransformer,\n) {\n  if ('error' in response) {\n    const error = transformer.deserialize(\n      response.error,\n    ) as inferRouterError<TRouter>;\n    return {\n      ok: false,\n      error: {\n        ...response,\n        error,\n      },\n    } as const;\n  }\n\n  const result = {\n    ...response.result,\n    ...((!response.result.type || response.result.type === 'data') && {\n      type: 'data',\n      data: transformer.deserialize(response.result.data),\n    }),\n  } as TRPCResultMessage<TOutput>['result'];\n  return { ok: true, result } as const;\n}\n\nclass TransformResultError extends Error {\n  constructor() {\n    super('Unable to transform response from server');\n  }\n}\n\n/**\n * Transforms and validates that the result is a valid TRPCResponse\n * @internal\n */\nexport function transformResult<TRouter extends AnyRouter, TOutput>(\n  response:\n    | TRPCResponse<TOutput, inferRouterError<TRouter>>\n    | TRPCResponseMessage<TOutput, inferRouterError<TRouter>>,\n  transformer: DataTransformer,\n): ReturnType<typeof transformResultInner> {\n  let result: ReturnType<typeof transformResultInner>;\n  try {\n    // Use the data transformers on the JSON-response\n    result = transformResultInner(response, transformer);\n  } catch {\n    throw new TransformResultError();\n  }\n\n  // check that output of the transformers is a valid TRPCResponse\n  if (\n    !result.ok &&\n    (!isObject(result.error.error) ||\n      typeof result.error.error['code'] !== 'number')\n  ) {\n    throw new TransformResultError();\n  }\n  if (result.ok && !isObject(result.result)) {\n    throw new TransformResultError();\n  }\n  return result;\n}\n","import type { StandardSchemaV1 } from \"./spec\";\n\n/** A schema error with useful information. */\n\nexport class StandardSchemaV1Error extends Error {\n  /** The schema issues. */\n  public readonly issues: ReadonlyArray<StandardSchemaV1.Issue>;\n\n  /**\n   * Creates a schema error with useful information.\n   *\n   * @param issues The schema issues.\n   */\n  constructor(issues: ReadonlyArray<StandardSchemaV1.Issue>) {\n    super(issues[0]?.message);\n    this.name = 'SchemaError';\n    this.issues = issues;\n  }\n}\n","import type { TRPCError } from '../error/TRPCError';\nimport type { TRPC_ERROR_CODES_BY_KEY, TRPCResponse } from '../rpc';\nimport { TRPC_ERROR_CODES_BY_NUMBER } from '../rpc';\nimport type { InvertKeyValue, ValueOf } from '../types';\nimport { isObject } from '../utils';\n\nexport const JSONRPC2_TO_HTTP_CODE: Record<\n  keyof typeof TRPC_ERROR_CODES_BY_KEY,\n  number\n> = {\n  PARSE_ERROR: 400,\n  BAD_REQUEST: 400,\n  UNAUTHORIZED: 401,\n  PAYMENT_REQUIRED: 402,\n  FORBIDDEN: 403,\n  NOT_FOUND: 404,\n  METHOD_NOT_SUPPORTED: 405,\n  TIMEOUT: 408,\n  CONFLICT: 409,\n  PRECONDITION_FAILED: 412,\n  PAYLOAD_TOO_LARGE: 413,\n  UNSUPPORTED_MEDIA_TYPE: 415,\n  UNPROCESSABLE_CONTENT: 422,\n  PRECONDITION_REQUIRED: 428,\n  TOO_MANY_REQUESTS: 429,\n  CLIENT_CLOSED_REQUEST: 499,\n  INTERNAL_SERVER_ERROR: 500,\n  NOT_IMPLEMENTED: 501,\n  BAD_GATEWAY: 502,\n  SERVICE_UNAVAILABLE: 503,\n  GATEWAY_TIMEOUT: 504,\n};\n\nexport const HTTP_CODE_TO_JSONRPC2: InvertKeyValue<\n  typeof JSONRPC2_TO_HTTP_CODE\n> = {\n  400: 'BAD_REQUEST',\n  401: 'UNAUTHORIZED',\n  402: 'PAYMENT_REQUIRED',\n  403: 'FORBIDDEN',\n  404: 'NOT_FOUND',\n  405: 'METHOD_NOT_SUPPORTED',\n  408: 'TIMEOUT',\n  409: 'CONFLICT',\n  412: 'PRECONDITION_FAILED',\n  413: 'PAYLOAD_TOO_LARGE',\n  415: 'UNSUPPORTED_MEDIA_TYPE',\n  422: 'UNPROCESSABLE_CONTENT',\n  428: 'PRECONDITION_REQUIRED',\n  429: 'TOO_MANY_REQUESTS',\n  499: 'CLIENT_CLOSED_REQUEST',\n  500: 'INTERNAL_SERVER_ERROR',\n  501: 'NOT_IMPLEMENTED',\n  502: 'BAD_GATEWAY',\n  503: 'SERVICE_UNAVAILABLE',\n  504: 'GATEWAY_TIMEOUT',\n} as const;\n\nexport function getStatusCodeFromKey(\n  code: keyof typeof TRPC_ERROR_CODES_BY_KEY,\n) {\n  return JSONRPC2_TO_HTTP_CODE[code] ?? 500;\n}\n\nexport function getStatusKeyFromCode(\n  code: keyof typeof HTTP_CODE_TO_JSONRPC2,\n): ValueOf<typeof HTTP_CODE_TO_JSONRPC2> {\n  return HTTP_CODE_TO_JSONRPC2[code] ?? 'INTERNAL_SERVER_ERROR';\n}\n\nexport function getHTTPStatusCode(json: TRPCResponse | TRPCResponse[]) {\n  const arr = Array.isArray(json) ? json : [json];\n  const httpStatuses = new Set<number>(\n    arr.map((res) => {\n      if ('error' in res && isObject(res.error.data)) {\n        if (typeof res.error.data?.['httpStatus'] === 'number') {\n          return res.error.data['httpStatus'];\n        }\n        const code = TRPC_ERROR_CODES_BY_NUMBER[res.error.code];\n        return getStatusCodeFromKey(code);\n      }\n      return 200;\n    }),\n  );\n\n  if (httpStatuses.size !== 1) {\n    return 207;\n  }\n\n  const httpStatus = httpStatuses.values().next().value;\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  return httpStatus!;\n}\n\nexport function getHTTPStatusCodeFromError(error: TRPCError) {\n  return getStatusCodeFromKey(error.code);\n}\n","import type { InvertKeyValue, ValueOf } from '../types';\n\n// reference: https://www.jsonrpc.org/specification\n\n/**\n * JSON-RPC 2.0 Error codes\n *\n * `-32000` to `-32099` are reserved for implementation-defined server-errors.\n * For tRPC we're copying the last digits of HTTP 4XX errors.\n */\nexport const TRPC_ERROR_CODES_BY_KEY = {\n  /**\n   * Invalid JSON was received by the server.\n   * An error occurred on the server while parsing the JSON text.\n   */\n  PARSE_ERROR: -32700,\n  /**\n   * The JSON sent is not a valid Request object.\n   */\n  BAD_REQUEST: -32600, // 400\n\n  // Internal JSON-RPC error\n  INTERNAL_SERVER_ERROR: -32603, // 500\n  NOT_IMPLEMENTED: -32603, // 501\n  BAD_GATEWAY: -32603, // 502\n  SERVICE_UNAVAILABLE: -32603, // 503\n  GATEWAY_TIMEOUT: -32603, // 504\n\n  // Implementation specific errors\n  UNAUTHORIZED: -32001, // 401\n  PAYMENT_REQUIRED: -32002, // 402\n  FORBIDDEN: -32003, // 403\n  NOT_FOUND: -32004, // 404\n  METHOD_NOT_SUPPORTED: -32005, // 405\n  TIMEOUT: -32008, // 408\n  CONFLICT: -32009, // 409\n  PRECONDITION_FAILED: -32012, // 412\n  PAYLOAD_TOO_LARGE: -32013, // 413\n  UNSUPPORTED_MEDIA_TYPE: -32015, // 415\n  UNPROCESSABLE_CONTENT: -32022, // 422\n  PRECONDITION_REQUIRED: -32028, // 428\n  TOO_MANY_REQUESTS: -32029, // 429\n  CLIENT_CLOSED_REQUEST: -32099, // 499\n} as const;\n\n// pure\nexport const TRPC_ERROR_CODES_BY_NUMBER: InvertKeyValue<\n  typeof TRPC_ERROR_CODES_BY_KEY\n> = {\n  [-32700]: 'PARSE_ERROR',\n  [-32600]: 'BAD_REQUEST',\n  [-32603]: 'INTERNAL_SERVER_ERROR',\n  [-32001]: 'UNAUTHORIZED',\n  [-32002]: 'PAYMENT_REQUIRED',\n  [-32003]: 'FORBIDDEN',\n  [-32004]: 'NOT_FOUND',\n  [-32005]: 'METHOD_NOT_SUPPORTED',\n  [-32008]: 'TIMEOUT',\n  [-32009]: 'CONFLICT',\n  [-32012]: 'PRECONDITION_FAILED',\n  [-32013]: 'PAYLOAD_TOO_LARGE',\n  [-32015]: 'UNSUPPORTED_MEDIA_TYPE',\n  [-32022]: 'UNPROCESSABLE_CONTENT',\n  [-32028]: 'PRECONDITION_REQUIRED',\n  [-32029]: 'TOO_MANY_REQUESTS',\n  [-32099]: 'CLIENT_CLOSED_REQUEST',\n};\n\nexport type TRPC_ERROR_CODE_NUMBER = ValueOf<typeof TRPC_ERROR_CODES_BY_KEY>;\nexport type TRPC_ERROR_CODE_KEY = keyof typeof TRPC_ERROR_CODES_BY_KEY;\n\n/**\n * tRPC error codes that are considered retryable\n * With out of the box SSE, the client will reconnect when these errors are encountered\n */\nexport const retryableRpcCodes: TRPC_ERROR_CODE_NUMBER[] = [\n  TRPC_ERROR_CODES_BY_KEY.BAD_GATEWAY,\n  TRPC_ERROR_CODES_BY_KEY.SERVICE_UNAVAILABLE,\n  TRPC_ERROR_CODES_BY_KEY.GATEWAY_TIMEOUT,\n  TRPC_ERROR_CODES_BY_KEY.INTERNAL_SERVER_ERROR,\n];\n","import { StandardSchemaV1Error } from '../vendor/standard-schema-v1/error';\nimport { type StandardSchemaV1 } from '../vendor/standard-schema-v1/spec';\n\n// zod / typeschema\nexport type ParserZodEsque<TInput, TParsedInput> = {\n  _input: TInput;\n  _output: TParsedInput;\n};\n\nexport type ParserValibotEsque<TInput, TParsedInput> = {\n  schema: {\n    _types?: {\n      input: TInput;\n      output: TParsedInput;\n    };\n  };\n};\n\nexport type ParserArkTypeEsque<TInput, TParsedInput> = {\n  inferIn: TInput;\n  infer: TParsedInput;\n};\n\nexport type ParserStandardSchemaEsque<TInput, TParsedInput> = StandardSchemaV1<\n  TInput,\n  TParsedInput\n>;\n\nexport type ParserMyZodEsque<TInput> = {\n  parse: (input: any) => TInput;\n};\n\nexport type ParserSuperstructEsque<TInput> = {\n  create: (input: unknown) => TInput;\n};\n\nexport type ParserCustomValidatorEsque<TInput> = (\n  input: unknown,\n) => Promise<TInput> | TInput;\n\nexport type ParserYupEsque<TInput> = {\n  validateSync: (input: unknown) => TInput;\n};\n\nexport type ParserScaleEsque<TInput> = {\n  assert(value: unknown): asserts value is TInput;\n};\n\nexport type ParserWithoutInput<TInput> =\n  | ParserCustomValidatorEsque<TInput>\n  | ParserMyZodEsque<TInput>\n  | ParserScaleEsque<TInput>\n  | ParserSuperstructEsque<TInput>\n  | ParserYupEsque<TInput>;\n\nexport type ParserWithInputOutput<TInput, TParsedInput> =\n  | ParserZodEsque<TInput, TParsedInput>\n  | ParserValibotEsque<TInput, TParsedInput>\n  | ParserArkTypeEsque<TInput, TParsedInput>\n  | ParserStandardSchemaEsque<TInput, TParsedInput>;\n\nexport type Parser = ParserWithInputOutput<any, any> | ParserWithoutInput<any>;\n\nexport type inferParser<TParser extends Parser> =\n  TParser extends ParserStandardSchemaEsque<infer $TIn, infer $TOut>\n    ? {\n        in: $TIn;\n        out: $TOut;\n      }\n    : TParser extends ParserWithInputOutput<infer $TIn, infer $TOut>\n      ? {\n          in: $TIn;\n          out: $TOut;\n        }\n      : TParser extends ParserWithoutInput<infer $InOut>\n        ? {\n            in: $InOut;\n            out: $InOut;\n          }\n        : never;\n\nexport type ParseFn<TType> = (value: unknown) => Promise<TType> | TType;\n\nexport function getParseFn<TType>(procedureParser: Parser): ParseFn<TType> {\n  const parser = procedureParser as any;\n  const isStandardSchema = '~standard' in parser;\n\n  if (typeof parser === 'function' && typeof parser.assert === 'function') {\n    // ParserArkTypeEsque - arktype schemas shouldn't be called as a function because they return a union type instead of throwing\n    return parser.assert.bind(parser);\n  }\n\n  if (typeof parser === 'function' && !isStandardSchema) {\n    // ParserValibotEsque (>= v0.31.0)\n    // ParserCustomValidatorEsque - note the check for standard-schema conformance - some libraries like `effect` use function schemas which are *not* a \"parse\" function.\n    return parser;\n  }\n\n  if (typeof parser.parseAsync === 'function') {\n    // ParserZodEsque\n    return parser.parseAsync.bind(parser);\n  }\n\n  if (typeof parser.parse === 'function') {\n    // ParserZodEsque\n    // ParserValibotEsque (< v0.13.0)\n    return parser.parse.bind(parser);\n  }\n\n  if (typeof parser.validateSync === 'function') {\n    // ParserYupEsque\n    return parser.validateSync.bind(parser);\n  }\n\n  if (typeof parser.create === 'function') {\n    // ParserSuperstructEsque\n    return parser.create.bind(parser);\n  }\n\n  if (typeof parser.assert === 'function') {\n    // ParserScaleEsque\n    return (value) => {\n      parser.assert(value);\n      return value as TType;\n    };\n  }\n\n  if (isStandardSchema) {\n    // StandardSchemaEsque\n    return async (value) => {\n      const result = await parser['~standard'].validate(value);\n      if (result.issues) {\n        throw new StandardSchemaV1Error(result.issues);\n      }\n      return result.value;\n    };\n  }\n\n  throw new Error('Could not find a validator fn');\n}\n","function _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (e.includes(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\nmodule.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import type { Observable } from '../observable';\nimport { createRecursiveProxy } from './createProxy';\nimport { defaultFormatter } from './error/formatter';\nimport { getTRPCErrorFromUnknown, TRPCError } from './error/TRPCError';\nimport type {\n  AnyProcedure,\n  ErrorHandlerOptions,\n  inferProcedureInput,\n  inferProcedureOutput,\n  LegacyObservableSubscriptionProcedure,\n} from './procedure';\nimport type { ProcedureCallOptions } from './procedureBuilder';\nimport type { AnyRootTypes, RootConfig } from './rootConfig';\nimport { defaultTransformer } from './transformer';\nimport type { MaybePromise, ValueOf } from './types';\nimport {\n  emptyObject,\n  isFunction,\n  isObject,\n  mergeWithoutOverrides,\n} from './utils';\n\nexport interface RouterRecord {\n  [key: string]: AnyProcedure | RouterRecord;\n}\n\ntype DecorateProcedure<TProcedure extends AnyProcedure> = (\n  input: inferProcedureInput<TProcedure>,\n) => Promise<\n  TProcedure['_def']['type'] extends 'subscription'\n    ? TProcedure extends LegacyObservableSubscriptionProcedure<any>\n      ? Observable<inferProcedureOutput<TProcedure>, TRPCError>\n      : inferProcedureOutput<TProcedure>\n    : inferProcedureOutput<TProcedure>\n>;\n\n/**\n * @internal\n */\nexport type DecorateRouterRecord<TRecord extends RouterRecord> = {\n  [TKey in keyof TRecord]: TRecord[TKey] extends infer $Value\n    ? $Value extends AnyProcedure\n      ? DecorateProcedure<$Value>\n      : $Value extends RouterRecord\n        ? DecorateRouterRecord<$Value>\n        : never\n    : never;\n};\n\n/**\n * @internal\n */\n\nexport type RouterCallerErrorHandler<TContext> = (\n  opts: ErrorHandlerOptions<TContext>,\n) => void;\n\n/**\n * @internal\n */\nexport type RouterCaller<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> = (\n  /**\n   * @note\n   * If passing a function, we recommend it's a cached function\n   * e.g. wrapped in `React.cache` to avoid unnecessary computations\n   */\n  ctx: TRoot['ctx'] | (() => MaybePromise<TRoot['ctx']>),\n  options?: {\n    onError?: RouterCallerErrorHandler<TRoot['ctx']>;\n    signal?: AbortSignal;\n  },\n) => DecorateRouterRecord<TRecord>;\n\n/**\n * @internal\n */\nconst lazyMarker = 'lazyMarker' as 'lazyMarker' & {\n  __brand: 'lazyMarker';\n};\nexport type Lazy<TAny> = (() => Promise<TAny>) & { [lazyMarker]: true };\n\ntype LazyLoader<TAny> = {\n  load: () => Promise<void>;\n  ref: Lazy<TAny>;\n};\n\nfunction once<T>(fn: () => T): () => T {\n  const uncalled = Symbol();\n  let result: T | typeof uncalled = uncalled;\n  return (): T => {\n    if (result === uncalled) {\n      result = fn();\n    }\n    return result;\n  };\n}\n\n/**\n * Lazy load a router\n * @see https://trpc.io/docs/server/merging-routers#lazy-load\n */\nexport function lazy<TRouter extends AnyRouter>(\n  importRouter: () => Promise<\n    | TRouter\n    | {\n        [key: string]: TRouter;\n      }\n  >,\n): Lazy<NoInfer<TRouter>> {\n  async function resolve(): Promise<TRouter> {\n    const mod = await importRouter();\n\n    // if the module is a router, return it\n    if (isRouter(mod)) {\n      return mod;\n    }\n\n    const routers = Object.values(mod);\n\n    if (routers.length !== 1 || !isRouter(routers[0])) {\n      throw new Error(\n        \"Invalid router module - either define exactly 1 export or return the router directly.\\nExample: `lazy(() => import('./slow.js').then((m) => m.slowRouter))`\",\n      );\n    }\n\n    return routers[0];\n  }\n\n  (resolve as Lazy<NoInfer<TRouter>>)[lazyMarker] = true as const;\n\n  return resolve as Lazy<NoInfer<TRouter>>;\n}\n\nfunction isLazy<TAny>(input: unknown): input is Lazy<TAny> {\n  return typeof input === 'function' && lazyMarker in input;\n}\n\n/**\n * @internal\n */\nexport interface RouterDef<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> {\n  _config: RootConfig<TRoot>;\n  router: true;\n  procedure?: never;\n  procedures: TRecord;\n  record: TRecord;\n  lazy: Record<string, LazyLoader<AnyRouter>>;\n}\n\nexport interface Router<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> {\n  _def: RouterDef<TRoot, TRecord>;\n  /**\n   * @see https://trpc.io/docs/v11/server/server-side-calls\n   */\n  createCaller: RouterCaller<TRoot, TRecord>;\n}\n\nexport type BuiltRouter<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> = Router<TRoot, TRecord> & TRecord;\n\nexport interface RouterBuilder<TRoot extends AnyRootTypes> {\n  <TIn extends CreateRouterOptions>(\n    _: TIn,\n  ): BuiltRouter<TRoot, DecorateCreateRouterOptions<TIn>>;\n}\n\nexport type AnyRouter = Router<any, any>;\n\nexport type inferRouterRootTypes<TRouter extends AnyRouter> =\n  TRouter['_def']['_config']['$types'];\n\nexport type inferRouterContext<TRouter extends AnyRouter> =\n  inferRouterRootTypes<TRouter>['ctx'];\nexport type inferRouterError<TRouter extends AnyRouter> =\n  inferRouterRootTypes<TRouter>['errorShape'];\nexport type inferRouterMeta<TRouter extends AnyRouter> =\n  inferRouterRootTypes<TRouter>['meta'];\n\nfunction isRouter(value: unknown): value is AnyRouter {\n  return (\n    isObject(value) && isObject(value['_def']) && 'router' in value['_def']\n  );\n}\n\nconst emptyRouter = {\n  _ctx: null as any,\n  _errorShape: null as any,\n  _meta: null as any,\n  queries: {},\n  mutations: {},\n  subscriptions: {},\n  errorFormatter: defaultFormatter,\n  transformer: defaultTransformer,\n};\n\n/**\n * Reserved words that can't be used as router or procedure names\n */\nconst reservedWords = [\n  /**\n   * Then is a reserved word because otherwise we can't return a promise that returns a Proxy\n   * since JS will think that `.then` is something that exists\n   */\n  'then',\n  /**\n   * `fn.call()` and `fn.apply()` are reserved words because otherwise we can't call a function using `.call` or `.apply`\n   */\n  'call',\n  'apply',\n];\n\n/** @internal */\nexport type CreateRouterOptions = {\n  [key: string]:\n    | AnyProcedure\n    | AnyRouter\n    | CreateRouterOptions\n    | Lazy<AnyRouter>;\n};\n\n/** @internal */\nexport type DecorateCreateRouterOptions<\n  TRouterOptions extends CreateRouterOptions,\n> = {\n  [K in keyof TRouterOptions]: TRouterOptions[K] extends infer $Value\n    ? $Value extends AnyProcedure\n      ? $Value\n      : $Value extends Router<any, infer TRecord>\n        ? TRecord\n        : $Value extends Lazy<Router<any, infer TRecord>>\n          ? TRecord\n          : $Value extends CreateRouterOptions\n            ? DecorateCreateRouterOptions<$Value>\n            : never\n    : never;\n};\n\n/**\n * @internal\n */\nexport function createRouterFactory<TRoot extends AnyRootTypes>(\n  config: RootConfig<TRoot>,\n) {\n  function createRouterInner<TInput extends CreateRouterOptions>(\n    input: TInput,\n  ): BuiltRouter<TRoot, DecorateCreateRouterOptions<TInput>> {\n    const reservedWordsUsed = new Set(\n      Object.keys(input).filter((v) => reservedWords.includes(v)),\n    );\n    if (reservedWordsUsed.size > 0) {\n      throw new Error(\n        'Reserved words used in `router({})` call: ' +\n          Array.from(reservedWordsUsed).join(', '),\n      );\n    }\n\n    const procedures: Record<string, AnyProcedure> = emptyObject();\n    const lazy: Record<string, LazyLoader<AnyRouter>> = emptyObject();\n\n    function createLazyLoader(opts: {\n      ref: Lazy<AnyRouter>;\n      path: readonly string[];\n      key: string;\n      aggregate: RouterRecord;\n    }): LazyLoader<AnyRouter> {\n      return {\n        ref: opts.ref,\n        load: once(async () => {\n          const router = await opts.ref();\n          const lazyPath = [...opts.path, opts.key];\n          const lazyKey = lazyPath.join('.');\n\n          opts.aggregate[opts.key] = step(router._def.record, lazyPath);\n\n          delete lazy[lazyKey];\n\n          // add lazy loaders for nested routers\n          for (const [nestedKey, nestedItem] of Object.entries(\n            router._def.lazy,\n          )) {\n            const nestedRouterKey = [...lazyPath, nestedKey].join('.');\n\n            // console.log('adding lazy', nestedRouterKey);\n            lazy[nestedRouterKey] = createLazyLoader({\n              ref: nestedItem.ref,\n              path: lazyPath,\n              key: nestedKey,\n              aggregate: opts.aggregate[opts.key] as RouterRecord,\n            });\n          }\n        }),\n      };\n    }\n\n    function step(from: CreateRouterOptions, path: readonly string[] = []) {\n      const aggregate: RouterRecord = emptyObject();\n      for (const [key, item] of Object.entries(from ?? {})) {\n        if (isLazy(item)) {\n          lazy[[...path, key].join('.')] = createLazyLoader({\n            path,\n            ref: item,\n            key,\n            aggregate,\n          });\n          continue;\n        }\n        if (isRouter(item)) {\n          aggregate[key] = step(item._def.record, [...path, key]);\n          continue;\n        }\n        if (!isProcedure(item)) {\n          // RouterRecord\n          aggregate[key] = step(item, [...path, key]);\n          continue;\n        }\n\n        const newPath = [...path, key].join('.');\n\n        if (procedures[newPath]) {\n          throw new Error(`Duplicate key: ${newPath}`);\n        }\n\n        procedures[newPath] = item;\n        aggregate[key] = item;\n      }\n\n      return aggregate;\n    }\n    const record = step(input);\n\n    const _def: AnyRouter['_def'] = {\n      _config: config,\n      router: true,\n      procedures,\n      lazy,\n      ...emptyRouter,\n      record,\n    };\n\n    const router: BuiltRouter<TRoot, {}> = {\n      ...(record as {}),\n      _def,\n      createCaller: createCallerFactory<TRoot>()({\n        _def,\n      }),\n    };\n    return router as BuiltRouter<TRoot, DecorateCreateRouterOptions<TInput>>;\n  }\n\n  return createRouterInner;\n}\n\nfunction isProcedure(\n  procedureOrRouter: ValueOf<CreateRouterOptions>,\n): procedureOrRouter is AnyProcedure {\n  return typeof procedureOrRouter === 'function';\n}\n\n/**\n * @internal\n */\nexport async function getProcedureAtPath(\n  router: Pick<Router<any, any>, '_def'>,\n  path: string,\n): Promise<AnyProcedure | null> {\n  const { _def } = router;\n  let procedure = _def.procedures[path];\n\n  while (!procedure) {\n    const key = Object.keys(_def.lazy).find((key) => path.startsWith(key));\n    // console.log(`found lazy: ${key ?? 'NOPE'} (fullPath: ${fullPath})`);\n\n    if (!key) {\n      return null;\n    }\n    // console.log('loading', key, '.......');\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const lazyRouter = _def.lazy[key]!;\n    await lazyRouter.load();\n\n    procedure = _def.procedures[path];\n  }\n\n  return procedure;\n}\n\n/**\n * @internal\n */\nexport async function callProcedure(\n  opts: ProcedureCallOptions<unknown> & {\n    router: AnyRouter;\n    allowMethodOverride?: boolean;\n  },\n) {\n  const { type, path } = opts;\n  const proc = await getProcedureAtPath(opts.router, path);\n  if (\n    !proc ||\n    !isProcedure(proc) ||\n    (proc._def.type !== type && !opts.allowMethodOverride)\n  ) {\n    throw new TRPCError({\n      code: 'NOT_FOUND',\n      message: `No \"${type}\"-procedure on path \"${path}\"`,\n    });\n  }\n\n  /* istanbul ignore if -- @preserve */\n  if (\n    proc._def.type !== type &&\n    opts.allowMethodOverride &&\n    proc._def.type === 'subscription'\n  ) {\n    throw new TRPCError({\n      code: 'METHOD_NOT_SUPPORTED',\n      message: `Method override is not supported for subscriptions`,\n    });\n  }\n\n  return proc(opts);\n}\n\nexport interface RouterCallerFactory<TRoot extends AnyRootTypes> {\n  <TRecord extends RouterRecord>(\n    router: Pick<Router<TRoot, TRecord>, '_def'>,\n  ): RouterCaller<TRoot, TRecord>;\n}\n\nexport function createCallerFactory<\n  TRoot extends AnyRootTypes,\n>(): RouterCallerFactory<TRoot> {\n  return function createCallerInner<TRecord extends RouterRecord>(\n    router: Pick<Router<TRoot, TRecord>, '_def'>,\n  ): RouterCaller<TRoot, TRecord> {\n    const { _def } = router;\n    type Context = TRoot['ctx'];\n\n    return function createCaller(ctxOrCallback, opts) {\n      return createRecursiveProxy<ReturnType<RouterCaller<any, any>>>(\n        async (innerOpts) => {\n          const { path, args } = innerOpts;\n          const fullPath = path.join('.');\n\n          if (path.length === 1 && path[0] === '_def') {\n            return _def;\n          }\n\n          const procedure = await getProcedureAtPath(router, fullPath);\n\n          let ctx: Context | undefined = undefined;\n          try {\n            if (!procedure) {\n              throw new TRPCError({\n                code: 'NOT_FOUND',\n                message: `No procedure found on path \"${path}\"`,\n              });\n            }\n            ctx = isFunction(ctxOrCallback)\n              ? await Promise.resolve(ctxOrCallback())\n              : ctxOrCallback;\n\n            return await procedure({\n              path: fullPath,\n              getRawInput: async () => args[0],\n              ctx,\n              type: procedure._def.type,\n              signal: opts?.signal,\n            });\n          } catch (cause) {\n            opts?.onError?.({\n              ctx,\n              error: getTRPCErrorFromUnknown(cause),\n              input: args[0],\n              path: fullPath,\n              type: procedure?._def.type ?? 'unknown',\n            });\n            throw cause;\n          }\n        },\n      );\n    };\n  };\n}\n\n/** @internal */\nexport type MergeRouters<\n  TRouters extends AnyRouter[],\n  TRoot extends AnyRootTypes = TRouters[0]['_def']['_config']['$types'],\n  TRecord extends RouterRecord = {},\n> = TRouters extends [\n  infer Head extends AnyRouter,\n  ...infer Tail extends AnyRouter[],\n]\n  ? MergeRouters<Tail, TRoot, Head['_def']['record'] & TRecord>\n  : BuiltRouter<TRoot, TRecord>;\n\nexport function mergeRouters<TRouters extends AnyRouter[]>(\n  ...routerList: [...TRouters]\n): MergeRouters<TRouters> {\n  const record = mergeWithoutOverrides(\n    {},\n    ...routerList.map((r) => r._def.record),\n  );\n  const errorFormatter = routerList.reduce(\n    (currentErrorFormatter, nextRouter) => {\n      if (\n        nextRouter._def._config.errorFormatter &&\n        nextRouter._def._config.errorFormatter !== defaultFormatter\n      ) {\n        if (\n          currentErrorFormatter !== defaultFormatter &&\n          currentErrorFormatter !== nextRouter._def._config.errorFormatter\n        ) {\n          throw new Error('You seem to have several error formatters');\n        }\n        return nextRouter._def._config.errorFormatter;\n      }\n      return currentErrorFormatter;\n    },\n    defaultFormatter,\n  );\n\n  const transformer = routerList.reduce((prev, current) => {\n    if (\n      current._def._config.transformer &&\n      current._def._config.transformer !== defaultTransformer\n    ) {\n      if (\n        prev !== defaultTransformer &&\n        prev !== current._def._config.transformer\n      ) {\n        throw new Error('You seem to have several transformers');\n      }\n      return current._def._config.transformer;\n    }\n    return prev;\n  }, defaultTransformer);\n\n  const router = createRouterFactory({\n    errorFormatter,\n    transformer,\n    isDev: routerList.every((r) => r._def._config.isDev),\n    allowOutsideOfServer: routerList.every(\n      (r) => r._def._config.allowOutsideOfServer,\n    ),\n    isServer: routerList.every((r) => r._def._config.isServer),\n    $types: routerList[0]?._def._config.$types,\n    sse: routerList[0]?._def._config.sse,\n  })(record);\n\n  return router as MergeRouters<TRouters>;\n}\n","var objectWithoutPropertiesLoose = require(\"./objectWithoutPropertiesLoose.js\");\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var s = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\nmodule.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import type { inferObservableValue, Observable } from '../observable';\nimport { getTRPCErrorFromUnknown, TRPCError } from './error/TRPCError';\nimport type {\n  AnyMiddlewareFunction,\n  MiddlewareBuilder,\n  MiddlewareFunction,\n  MiddlewareResult,\n} from './middleware';\nimport {\n  createInputMiddleware,\n  createOutputMiddleware,\n  middlewareMarker,\n} from './middleware';\nimport type { inferParser, Parser } from './parser';\nimport { getParseFn } from './parser';\nimport type {\n  AnyMutationProcedure,\n  AnyProcedure,\n  AnyQueryProcedure,\n  LegacyObservableSubscriptionProcedure,\n  MutationProcedure,\n  ProcedureType,\n  QueryProcedure,\n  SubscriptionProcedure,\n} from './procedure';\nimport type { inferTrackedOutput } from './stream/tracked';\nimport type {\n  GetRawInputFn,\n  MaybePromise,\n  Overwrite,\n  Simplify,\n  TypeError,\n} from './types';\nimport type { UnsetMarker } from './utils';\nimport { mergeWithoutOverrides } from './utils';\n\ntype IntersectIfDefined<TType, TWith> = TType extends UnsetMarker\n  ? TWith\n  : TWith extends UnsetMarker\n    ? TType\n    : Simplify<TType & TWith>;\n\ntype DefaultValue<TValue, TFallback> = TValue extends UnsetMarker\n  ? TFallback\n  : TValue;\n\ntype inferAsyncIterable<TOutput> =\n  TOutput extends AsyncIterable<infer $Yield, infer $Return, infer $Next>\n    ? {\n        yield: $Yield;\n        return: $Return;\n        next: $Next;\n      }\n    : never;\ntype inferSubscriptionOutput<TOutput> =\n  TOutput extends AsyncIterable<any>\n    ? AsyncIterable<\n        inferTrackedOutput<inferAsyncIterable<TOutput>['yield']>,\n        inferAsyncIterable<TOutput>['return'],\n        inferAsyncIterable<TOutput>['next']\n      >\n    : TypeError<'Subscription output could not be inferred'>;\n\nexport type CallerOverride<TContext> = (opts: {\n  args: unknown[];\n  invoke: (opts: ProcedureCallOptions<TContext>) => Promise<unknown>;\n  _def: AnyProcedure['_def'];\n}) => Promise<unknown>;\ntype ProcedureBuilderDef<TMeta> = {\n  procedure: true;\n  inputs: Parser[];\n  output?: Parser;\n  meta?: TMeta;\n  resolver?: ProcedureBuilderResolver;\n  middlewares: AnyMiddlewareFunction[];\n  /**\n   * @deprecated use `type` instead\n   */\n  mutation?: boolean;\n  /**\n   * @deprecated use `type` instead\n   */\n  query?: boolean;\n  /**\n   * @deprecated use `type` instead\n   */\n  subscription?: boolean;\n  type?: ProcedureType;\n  caller?: CallerOverride<unknown>;\n};\n\ntype AnyProcedureBuilderDef = ProcedureBuilderDef<any>;\n\n/**\n * Procedure resolver options (what the `.query()`, `.mutation()`, and `.subscription()` functions receive)\n * @internal\n */\nexport interface ProcedureResolverOptions<\n  TContext,\n  _TMeta,\n  TContextOverridesIn,\n  TInputOut,\n> {\n  ctx: Simplify<Overwrite<TContext, TContextOverridesIn>>;\n  input: TInputOut extends UnsetMarker ? undefined : TInputOut;\n  /**\n   * The AbortSignal of the request\n   */\n  signal: AbortSignal | undefined;\n  /**\n   * The path of the procedure\n   */\n  path: string;\n}\n\n/**\n * A procedure resolver\n */\ntype ProcedureResolver<\n  TContext,\n  TMeta,\n  TContextOverrides,\n  TInputOut,\n  TOutputParserIn,\n  $Output,\n> = (\n  opts: ProcedureResolverOptions<TContext, TMeta, TContextOverrides, TInputOut>,\n) => MaybePromise<\n  // If an output parser is defined, we need to return what the parser expects, otherwise we return the inferred type\n  DefaultValue<TOutputParserIn, $Output>\n>;\n\ntype AnyResolver = ProcedureResolver<any, any, any, any, any, any>;\nexport type AnyProcedureBuilder = ProcedureBuilder<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>;\n\n/**\n * Infer the context type from a procedure builder\n * Useful to create common helper functions for different procedures\n */\nexport type inferProcedureBuilderResolverOptions<\n  TProcedureBuilder extends AnyProcedureBuilder,\n> =\n  TProcedureBuilder extends ProcedureBuilder<\n    infer TContext,\n    infer TMeta,\n    infer TContextOverrides,\n    infer _TInputIn,\n    infer TInputOut,\n    infer _TOutputIn,\n    infer _TOutputOut,\n    infer _TCaller\n  >\n    ? ProcedureResolverOptions<\n        TContext,\n        TMeta,\n        TContextOverrides,\n        TInputOut extends UnsetMarker\n          ? // if input is not set, we don't want to infer it as `undefined` since a procedure further down the chain might have set an input\n            unknown\n          : TInputOut extends object\n            ? Simplify<\n                TInputOut & {\n                  /**\n                   * Extra input params might have been added by a `.input()` further down the chain\n                   */\n                  [keyAddedByInputCallFurtherDown: string]: unknown;\n                }\n              >\n            : TInputOut\n      >\n    : never;\n\nexport interface ProcedureBuilder<\n  TContext,\n  TMeta,\n  TContextOverrides,\n  TInputIn,\n  TInputOut,\n  TOutputIn,\n  TOutputOut,\n  TCaller extends boolean,\n> {\n  /**\n   * Add an input parser to the procedure.\n   * @see https://trpc.io/docs/v11/server/validators\n   */\n  input<$Parser extends Parser>(\n    schema: TInputOut extends UnsetMarker\n      ? $Parser\n      : inferParser<$Parser>['out'] extends Record<string, unknown> | undefined\n        ? TInputOut extends Record<string, unknown> | undefined\n          ? undefined extends inferParser<$Parser>['out'] // if current is optional the previous must be too\n            ? undefined extends TInputOut\n              ? $Parser\n              : TypeError<'Cannot chain an optional parser to a required parser'>\n            : $Parser\n          : TypeError<'All input parsers did not resolve to an object'>\n        : TypeError<'All input parsers did not resolve to an object'>,\n  ): ProcedureBuilder<\n    TContext,\n    TMeta,\n    TContextOverrides,\n    IntersectIfDefined<TInputIn, inferParser<$Parser>['in']>,\n    IntersectIfDefined<TInputOut, inferParser<$Parser>['out']>,\n    TOutputIn,\n    TOutputOut,\n    TCaller\n  >;\n  /**\n   * Add an output parser to the procedure.\n   * @see https://trpc.io/docs/v11/server/validators\n   */\n  output<$Parser extends Parser>(\n    schema: $Parser,\n  ): ProcedureBuilder<\n    TContext,\n    TMeta,\n    TContextOverrides,\n    TInputIn,\n    TInputOut,\n    IntersectIfDefined<TOutputIn, inferParser<$Parser>['in']>,\n    IntersectIfDefined<TOutputOut, inferParser<$Parser>['out']>,\n    TCaller\n  >;\n  /**\n   * Add a meta data to the procedure.\n   * @see https://trpc.io/docs/v11/server/metadata\n   */\n  meta(\n    meta: TMeta,\n  ): ProcedureBuilder<\n    TContext,\n    TMeta,\n    TContextOverrides,\n    TInputIn,\n    TInputOut,\n    TOutputIn,\n    TOutputOut,\n    TCaller\n  >;\n  /**\n   * Add a middleware to the procedure.\n   * @see https://trpc.io/docs/v11/server/middlewares\n   */\n  use<$ContextOverridesOut>(\n    fn:\n      | MiddlewareBuilder<\n          Overwrite<TContext, TContextOverrides>,\n          TMeta,\n          $ContextOverridesOut,\n          TInputOut\n        >\n      | MiddlewareFunction<\n          TContext,\n          TMeta,\n          TContextOverrides,\n          $ContextOverridesOut,\n          TInputOut\n        >,\n  ): ProcedureBuilder<\n    TContext,\n    TMeta,\n    Overwrite<TContextOverrides, $ContextOverridesOut>,\n    TInputIn,\n    TInputOut,\n    TOutputIn,\n    TOutputOut,\n    TCaller\n  >;\n\n  /**\n   * @deprecated use {@link concat} instead\n   */\n  unstable_concat<\n    $Context,\n    $Meta,\n    $ContextOverrides,\n    $InputIn,\n    $InputOut,\n    $OutputIn,\n    $OutputOut,\n  >(\n    builder: Overwrite<TContext, TContextOverrides> extends $Context\n      ? TMeta extends $Meta\n        ? ProcedureBuilder<\n            $Context,\n            $Meta,\n            $ContextOverrides,\n            $InputIn,\n            $InputOut,\n            $OutputIn,\n            $OutputOut,\n            TCaller\n          >\n        : TypeError<'Meta mismatch'>\n      : TypeError<'Context mismatch'>,\n  ): ProcedureBuilder<\n    TContext,\n    TMeta,\n    Overwrite<TContextOverrides, $ContextOverrides>,\n    IntersectIfDefined<TInputIn, $InputIn>,\n    IntersectIfDefined<TInputOut, $InputOut>,\n    IntersectIfDefined<TOutputIn, $OutputIn>,\n    IntersectIfDefined<TOutputOut, $OutputOut>,\n    TCaller\n  >;\n\n  /**\n   * Combine two procedure builders\n   */\n  concat<\n    $Context,\n    $Meta,\n    $ContextOverrides,\n    $InputIn,\n    $InputOut,\n    $OutputIn,\n    $OutputOut,\n  >(\n    builder: Overwrite<TContext, TContextOverrides> extends $Context\n      ? TMeta extends $Meta\n        ? ProcedureBuilder<\n            $Context,\n            $Meta,\n            $ContextOverrides,\n            $InputIn,\n            $InputOut,\n            $OutputIn,\n            $OutputOut,\n            TCaller\n          >\n        : TypeError<'Meta mismatch'>\n      : TypeError<'Context mismatch'>,\n  ): ProcedureBuilder<\n    TContext,\n    TMeta,\n    Overwrite<TContextOverrides, $ContextOverrides>,\n    IntersectIfDefined<TInputIn, $InputIn>,\n    IntersectIfDefined<TInputOut, $InputOut>,\n    IntersectIfDefined<TOutputIn, $OutputIn>,\n    IntersectIfDefined<TOutputOut, $OutputOut>,\n    TCaller\n  >;\n  /**\n   * Query procedure\n   * @see https://trpc.io/docs/v11/concepts#vocabulary\n   */\n  query<$Output>(\n    resolver: ProcedureResolver<\n      TContext,\n      TMeta,\n      TContextOverrides,\n      TInputOut,\n      TOutputIn,\n      $Output\n    >,\n  ): TCaller extends true\n    ? (\n        input: DefaultValue<TInputIn, void>,\n      ) => Promise<DefaultValue<TOutputOut, $Output>>\n    : QueryProcedure<{\n        input: DefaultValue<TInputIn, void>;\n        output: DefaultValue<TOutputOut, $Output>;\n        meta: TMeta;\n      }>;\n\n  /**\n   * Mutation procedure\n   * @see https://trpc.io/docs/v11/concepts#vocabulary\n   */\n  mutation<$Output>(\n    resolver: ProcedureResolver<\n      TContext,\n      TMeta,\n      TContextOverrides,\n      TInputOut,\n      TOutputIn,\n      $Output\n    >,\n  ): TCaller extends true\n    ? (\n        input: DefaultValue<TInputIn, void>,\n      ) => Promise<DefaultValue<TOutputOut, $Output>>\n    : MutationProcedure<{\n        input: DefaultValue<TInputIn, void>;\n        output: DefaultValue<TOutputOut, $Output>;\n        meta: TMeta;\n      }>;\n\n  /**\n   * Subscription procedure\n   * @see https://trpc.io/docs/v11/server/subscriptions\n   */\n  subscription<$Output extends AsyncIterable<any, void, any>>(\n    resolver: ProcedureResolver<\n      TContext,\n      TMeta,\n      TContextOverrides,\n      TInputOut,\n      TOutputIn,\n      $Output\n    >,\n  ): TCaller extends true\n    ? TypeError<'Not implemented'>\n    : SubscriptionProcedure<{\n        input: DefaultValue<TInputIn, void>;\n        output: inferSubscriptionOutput<DefaultValue<TOutputOut, $Output>>;\n        meta: TMeta;\n      }>;\n  /**\n   * @deprecated Using subscriptions with an observable is deprecated. Use an async generator instead.\n   * This feature will be removed in v12 of tRPC.\n   * @see https://trpc.io/docs/v11/server/subscriptions\n   */\n  subscription<$Output extends Observable<any, any>>(\n    resolver: ProcedureResolver<\n      TContext,\n      TMeta,\n      TContextOverrides,\n      TInputOut,\n      TOutputIn,\n      $Output\n    >,\n  ): TCaller extends true\n    ? TypeError<'Not implemented'>\n    : LegacyObservableSubscriptionProcedure<{\n        input: DefaultValue<TInputIn, void>;\n        output: inferObservableValue<DefaultValue<TOutputOut, $Output>>;\n        meta: TMeta;\n      }>;\n  /**\n   * Overrides the way a procedure is invoked\n   * Do not use this unless you know what you're doing - this is an experimental API\n   */\n  experimental_caller(\n    caller: CallerOverride<TContext>,\n  ): ProcedureBuilder<\n    TContext,\n    TMeta,\n    TContextOverrides,\n    TInputIn,\n    TInputOut,\n    TOutputIn,\n    TOutputOut,\n    true\n  >;\n  /**\n   * @internal\n   */\n  _def: ProcedureBuilderDef<TMeta>;\n}\n\ntype ProcedureBuilderResolver = (\n  opts: ProcedureResolverOptions<any, any, any, any>,\n) => Promise<unknown>;\n\nfunction createNewBuilder(\n  def1: AnyProcedureBuilderDef,\n  def2: Partial<AnyProcedureBuilderDef>,\n): AnyProcedureBuilder {\n  const { middlewares = [], inputs, meta, ...rest } = def2;\n\n  // TODO: maybe have a fn here to warn about calls\n  return createBuilder({\n    ...mergeWithoutOverrides(def1, rest),\n    inputs: [...def1.inputs, ...(inputs ?? [])],\n    middlewares: [...def1.middlewares, ...middlewares],\n    meta: def1.meta && meta ? { ...def1.meta, ...meta } : (meta ?? def1.meta),\n  });\n}\n\nexport function createBuilder<TContext, TMeta>(\n  initDef: Partial<AnyProcedureBuilderDef> = {},\n): ProcedureBuilder<\n  TContext,\n  TMeta,\n  object,\n  UnsetMarker,\n  UnsetMarker,\n  UnsetMarker,\n  UnsetMarker,\n  false\n> {\n  const _def: AnyProcedureBuilderDef = {\n    procedure: true,\n    inputs: [],\n    middlewares: [],\n    ...initDef,\n  };\n\n  const builder: AnyProcedureBuilder = {\n    _def,\n    input(input) {\n      const parser = getParseFn(input as Parser);\n      return createNewBuilder(_def, {\n        inputs: [input as Parser],\n        middlewares: [createInputMiddleware(parser)],\n      });\n    },\n    output(output: Parser) {\n      const parser = getParseFn(output);\n      return createNewBuilder(_def, {\n        output,\n        middlewares: [createOutputMiddleware(parser)],\n      });\n    },\n    meta(meta) {\n      return createNewBuilder(_def, {\n        meta,\n      });\n    },\n    use(middlewareBuilderOrFn) {\n      // Distinguish between a middleware builder and a middleware function\n      const middlewares =\n        '_middlewares' in middlewareBuilderOrFn\n          ? middlewareBuilderOrFn._middlewares\n          : [middlewareBuilderOrFn];\n\n      return createNewBuilder(_def, {\n        middlewares: middlewares,\n      });\n    },\n    unstable_concat(builder) {\n      return createNewBuilder(_def, (builder as AnyProcedureBuilder)._def);\n    },\n    concat(builder) {\n      return createNewBuilder(_def, (builder as AnyProcedureBuilder)._def);\n    },\n    query(resolver) {\n      return createResolver(\n        { ..._def, type: 'query' },\n        resolver,\n      ) as AnyQueryProcedure;\n    },\n    mutation(resolver) {\n      return createResolver(\n        { ..._def, type: 'mutation' },\n        resolver,\n      ) as AnyMutationProcedure;\n    },\n    subscription(resolver: ProcedureResolver<any, any, any, any, any, any>) {\n      return createResolver({ ..._def, type: 'subscription' }, resolver) as any;\n    },\n    experimental_caller(caller) {\n      return createNewBuilder(_def, {\n        caller,\n      }) as any;\n    },\n  };\n\n  return builder;\n}\n\nfunction createResolver(\n  _defIn: AnyProcedureBuilderDef & { type: ProcedureType },\n  resolver: AnyResolver,\n) {\n  const finalBuilder = createNewBuilder(_defIn, {\n    resolver,\n    middlewares: [\n      async function resolveMiddleware(opts) {\n        const data = await resolver(opts);\n        return {\n          marker: middlewareMarker,\n          ok: true,\n          data,\n          ctx: opts.ctx,\n        } as const;\n      },\n    ],\n  });\n  const _def: AnyProcedure['_def'] = {\n    ...finalBuilder._def,\n    type: _defIn.type,\n    experimental_caller: Boolean(finalBuilder._def.caller),\n    meta: finalBuilder._def.meta,\n    $types: null as any,\n  };\n\n  const invoke = createProcedureCaller(finalBuilder._def);\n  const callerOverride = finalBuilder._def.caller;\n  if (!callerOverride) {\n    return invoke;\n  }\n  const callerWrapper = async (...args: unknown[]) => {\n    return await callerOverride({\n      args,\n      invoke,\n      _def: _def,\n    });\n  };\n\n  callerWrapper._def = _def;\n\n  return callerWrapper;\n}\n\n/**\n * @internal\n */\nexport interface ProcedureCallOptions<TContext> {\n  ctx: TContext;\n  getRawInput: GetRawInputFn;\n  input?: unknown;\n  path: string;\n  type: ProcedureType;\n  signal: AbortSignal | undefined;\n}\n\nconst codeblock = `\nThis is a client-only function.\nIf you want to call this function on the server, see https://trpc.io/docs/v11/server/server-side-calls\n`.trim();\n\n// run the middlewares recursively with the resolver as the last one\nasync function callRecursive(\n  index: number,\n  _def: AnyProcedureBuilderDef,\n  opts: ProcedureCallOptions<any>,\n): Promise<MiddlewareResult<any>> {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const middleware = _def.middlewares[index]!;\n    const result = await middleware({\n      ...opts,\n      meta: _def.meta,\n      input: opts.input,\n      next(_nextOpts?: any) {\n        const nextOpts = _nextOpts as\n          | {\n              ctx?: Record<string, unknown>;\n              input?: unknown;\n              getRawInput?: GetRawInputFn;\n            }\n          | undefined;\n\n        return callRecursive(index + 1, _def, {\n          ...opts,\n          ctx: nextOpts?.ctx ? { ...opts.ctx, ...nextOpts.ctx } : opts.ctx,\n          input: nextOpts && 'input' in nextOpts ? nextOpts.input : opts.input,\n          getRawInput: nextOpts?.getRawInput ?? opts.getRawInput,\n        });\n      },\n    });\n\n    return result;\n  } catch (cause) {\n    return {\n      ok: false,\n      error: getTRPCErrorFromUnknown(cause),\n      marker: middlewareMarker,\n    };\n  }\n}\n\nfunction createProcedureCaller(_def: AnyProcedureBuilderDef): AnyProcedure {\n  async function procedure(opts: ProcedureCallOptions<unknown>) {\n    // is direct server-side call\n    if (!opts || !('getRawInput' in opts)) {\n      throw new Error(codeblock);\n    }\n\n    // there's always at least one \"next\" since we wrap this.resolver in a middleware\n    const result = await callRecursive(0, _def, opts);\n\n    if (!result) {\n      throw new TRPCError({\n        code: 'INTERNAL_SERVER_ERROR',\n        message:\n          'No result from middlewares - did you forget to `return next()`?',\n      });\n    }\n    if (!result.ok) {\n      // re-throw original error\n      throw result.error;\n    }\n    return result.data;\n  }\n\n  procedure._def = _def;\n  procedure.procedure = true;\n  procedure.meta = _def.meta;\n\n  // FIXME typecast shouldn't be needed - fixittt\n  return procedure as unknown as AnyProcedure;\n}\n","function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports, _typeof(o);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var _typeof = require(\"./typeof.js\")[\"default\"];\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nmodule.exports = toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var _typeof = require(\"./typeof.js\")[\"default\"];\nvar toPrimitive = require(\"./toPrimitive.js\");\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nmodule.exports = toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var toPropertyKey = require(\"./toPropertyKey.js\");\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var defineProperty = require(\"./defineProperty.js\");\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nmodule.exports = _objectSpread2, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import { isObject } from '../utils';\n\nexport function isAbortError(\n  error: unknown,\n): error is DOMException | Error | { name: 'AbortError' } {\n  return isObject(error) && error['name'] === 'AbortError';\n}\n\nexport function throwAbortError(message = 'AbortError'): never {\n  throw new DOMException(message, 'AbortError');\n}\n","/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nfunction isObject(o: unknown): o is Record<string, unknown> {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n  \nexport function isPlainObject(o: unknown): o is Record<string, unknown> {\n  var ctor,prot;\n\n  if (isObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (ctor === undefined) return true;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n};\n","import { getHTTPStatusCodeFromError } from '../http/getHTTPStatusCode';\nimport type { ProcedureType } from '../procedure';\nimport type { AnyRootTypes, RootConfig } from '../rootConfig';\nimport { TRPC_ERROR_CODES_BY_KEY } from '../rpc';\nimport type { DefaultErrorShape } from './formatter';\nimport type { TRPCError } from './TRPCError';\n\n/**\n * @internal\n */\nexport function getErrorShape<TRoot extends AnyRootTypes>(opts: {\n  config: RootConfig<TRoot>;\n  error: TRPCError;\n  type: ProcedureType | 'unknown';\n  path: string | undefined;\n  input: unknown;\n  ctx: TRoot['ctx'] | undefined;\n}): TRoot['errorShape'] {\n  const { path, error, config } = opts;\n  const { code } = opts.error;\n  const shape: DefaultErrorShape = {\n    message: error.message,\n    code: TRPC_ERROR_CODES_BY_KEY[code],\n    data: {\n      code,\n      httpStatus: getHTTPStatusCodeFromError(error),\n    },\n  };\n  if (config.isDev && typeof opts.error.stack === 'string') {\n    shape.data.stack = opts.error.stack;\n  }\n  if (typeof path === 'string') {\n    shape.data.path = path;\n  }\n  return config.errorFormatter({ ...opts, shape });\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\n \n \n\nimport type {\n  PromiseExecutor,\n  PromiseWithResolvers,\n  ProxyPromise,\n  SubscribedPromise,\n} from \"./types\";\n\n/** Memory safe (weakmapped) cache of the ProxyPromise for each Promise,\n * which is retained for the lifetime of the original Promise.\n */\nconst subscribableCache = new WeakMap<\n  PromiseLike<unknown>,\n  ProxyPromise<unknown>\n>();\n\n/** A NOOP function allowing a consistent interface for settled\n * SubscribedPromises (settled promises are not subscribed - they resolve\n * immediately). */\nconst NOOP = () => {\n  // noop\n};\n\n/**\n * Every `Promise<T>` can be shadowed by a single `ProxyPromise<T>`. It is\n * created once, cached and reused throughout the lifetime of the Promise. Get a\n * Promise's ProxyPromise using `Unpromise.proxy(promise)`.\n *\n * The `ProxyPromise<T>` attaches handlers to the original `Promise<T>`\n * `.then()` and `.catch()` just once. Promises derived from it use a\n * subscription- (and unsubscription-) based mechanism that monitors these\n * handlers.\n *\n * Every time you call `.subscribe()`, `.then()` `.catch()` or `.finally()` on a\n * `ProxyPromise<T>` it returns a `SubscribedPromise<T>` having an additional\n * `unsubscribe()` method. Calling `unsubscribe()` detaches reference chains\n * from the original, potentially long-lived Promise, eliminating memory leaks.\n *\n * This approach can eliminate the memory leaks that otherwise come about from\n * repeated `race()` or `any()` calls invoking `.then()` and `.catch()` multiple\n * times on the same long-lived native Promise (subscriptions which can never be\n * cleaned up).\n *\n * `Unpromise.race(promises)` is a reference implementation of `Promise.race`\n * avoiding memory leaks when using long-lived unsettled Promises.\n *\n * `Unpromise.any(promises)` is a reference implementation of `Promise.any`\n * avoiding memory leaks when using long-lived unsettled Promises.\n *\n * `Unpromise.resolve(promise)` returns an ephemeral `SubscribedPromise<T>` for\n * any given `Promise<T>` facilitating arbitrary async/await patterns. Behind\n * the scenes, `resolve` is implemented simply as\n * `Unpromise.proxy(promise).subscribe()`. Don't forget to call `.unsubscribe()`\n * to tidy up!\n *\n */\nexport class Unpromise<T> implements ProxyPromise<T> {\n  /** INSTANCE IMPLEMENTATION */\n\n  /** The promise shadowed by this Unpromise<T>  */\n  protected readonly promise: Promise<T> | PromiseLike<T>;\n\n  /** Promises expecting eventual settlement (unless unsubscribed first). This list is deleted\n   * after the original promise settles - no further notifications will be issued. */\n  protected subscribers: ReadonlyArray<PromiseWithResolvers<T>> | null = [];\n\n  /** The Promise's settlement (recorded when it fulfils or rejects). This is consulted when\n   * calling .subscribe() .then() .catch() .finally() to see if an immediately-resolving Promise\n   * can be returned, and therefore subscription can be bypassed. */\n  protected settlement: PromiseSettledResult<T> | null = null;\n\n  /** Constructor accepts a normal Promise executor function like `new\n   * Unpromise((resolve, reject) => {...})` or accepts a pre-existing Promise\n   * like `new Unpromise(existingPromise)`. Adds `.then()` and `.catch()`\n   * handlers to the Promise. These handlers pass fulfilment and rejection\n   * notifications to downstream subscribers and maintains records of value\n   * or error if the Promise ever settles. */\n  protected constructor(promise: Promise<T>);\n  protected constructor(promise: PromiseLike<T>);\n  protected constructor(executor: PromiseExecutor<T>);\n  protected constructor(arg: Promise<T> | PromiseLike<T> | PromiseExecutor<T>) {\n    // handle either a Promise or a Promise executor function\n    if (typeof arg === \"function\") {\n      this.promise = new Promise(arg);\n    } else {\n      this.promise = arg;\n    }\n\n    // subscribe for eventual fulfilment and rejection\n\n    // handle PromiseLike objects (that at least have .then)\n    const thenReturn = this.promise.then((value) => {\n      // atomically record fulfilment and detach subscriber list\n      const { subscribers } = this;\n      this.subscribers = null;\n      this.settlement = {\n        status: \"fulfilled\",\n        value,\n      };\n      // notify fulfilment to subscriber list\n      subscribers?.forEach(({ resolve }) => {\n        resolve(value);\n      });\n    });\n\n    // handle Promise (that also have a .catch behaviour)\n    if (\"catch\" in thenReturn) {\n      thenReturn.catch((reason) => {\n        // atomically record rejection and detach subscriber list\n        const { subscribers } = this;\n        this.subscribers = null;\n        this.settlement = {\n          status: \"rejected\",\n          reason,\n        };\n        // notify rejection to subscriber list\n        subscribers?.forEach(({ reject }) => {\n          reject(reason);\n        });\n      });\n    }\n  }\n\n  /** Create a promise that mitigates uncontrolled subscription to a long-lived\n   * Promise via .then() and .catch() - otherwise a source of memory leaks.\n   *\n   * The returned promise has an `unsubscribe()` method which can be called when\n   * the Promise is no longer being tracked by application logic, and which\n   * ensures that there is no reference chain from the original promise to the\n   * new one, and therefore no memory leak.\n   *\n   * If original promise has not yet settled, this adds a new unique promise\n   * that listens to then/catch events, along with an `unsubscribe()` method to\n   * detach it.\n   *\n   * If original promise has settled, then creates a new Promise.resolve() or\n   * Promise.reject() and provided unsubscribe is a noop.\n   *\n   * If you call `unsubscribe()` before the returned Promise has settled, it\n   * will never settle.\n   */\n  subscribe(): SubscribedPromise<T> {\n    // in all cases we will combine some promise with its unsubscribe function\n    let promise: Promise<T>;\n    let unsubscribe: () => void;\n\n    const { settlement } = this;\n    if (settlement === null) {\n      // not yet settled - subscribe new promise. Expect eventual settlement\n      if (this.subscribers === null) {\n        // invariant - it is not settled, so it must have subscribers\n        throw new Error(\"Unpromise settled but still has subscribers\");\n      }\n      const subscriber = withResolvers<T>();\n      this.subscribers = listWithMember(this.subscribers, subscriber);\n      promise = subscriber.promise;\n      unsubscribe = () => {\n        if (this.subscribers !== null) {\n          this.subscribers = listWithoutMember(this.subscribers, subscriber);\n        }\n      };\n    } else {\n      // settled - don't create subscribed promise. Just resolve or reject\n      const { status } = settlement;\n      if (status === \"fulfilled\") {\n        promise = Promise.resolve(settlement.value);\n      } else {\n        promise = Promise.reject(settlement.reason);\n      }\n      unsubscribe = NOOP;\n    }\n\n    // extend promise signature with the extra method\n    return Object.assign(promise, { unsubscribe });\n  }\n\n  /** STANDARD PROMISE METHODS (but returning a SubscribedPromise) */\n\n  then<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | null\n       ,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | null\n       \n  ): SubscribedPromise<TResult1 | TResult2> {\n    const subscribed = this.subscribe();\n    const { unsubscribe } = subscribed;\n    return Object.assign(subscribed.then(onfulfilled, onrejected), {\n      unsubscribe,\n    });\n  }\n\n  catch<TResult = never>(\n    onrejected?:\n      | ((reason: any) => TResult | PromiseLike<TResult>)\n      | null\n       \n  ): SubscribedPromise<T | TResult> {\n    const subscribed = this.subscribe();\n    const { unsubscribe } = subscribed;\n    return Object.assign(subscribed.catch(onrejected), {\n      unsubscribe,\n    });\n  }\n\n  finally(onfinally?: (() => void) | null  ): SubscribedPromise<T> {\n    const subscribed = this.subscribe();\n    const { unsubscribe } = subscribed;\n    return Object.assign(subscribed.finally(onfinally), {\n      unsubscribe,\n    });\n  }\n\n  /** TOSTRING SUPPORT */\n\n  readonly [Symbol.toStringTag] = \"Unpromise\";\n\n  /** Unpromise STATIC METHODS */\n\n  /** Create or Retrieve the proxy Unpromise (a re-used Unpromise for the VM lifetime\n   * of the provided Promise reference) */\n  static proxy<T>(promise: PromiseLike<T>): ProxyPromise<T> {\n    const cached = Unpromise.getSubscribablePromise(promise);\n    return typeof cached !== \"undefined\"\n      ? cached\n      : Unpromise.createSubscribablePromise(promise);\n  }\n\n  /** Create and store an Unpromise keyed by an original Promise. */\n  protected static createSubscribablePromise<T>(promise: PromiseLike<T>) {\n    const created = new Unpromise<T>(promise);\n    subscribableCache.set(promise, created as Unpromise<unknown>); // resolve promise to unpromise\n    subscribableCache.set(created, created as Unpromise<unknown>); // resolve the unpromise to itself\n    return created;\n  }\n\n  /** Retrieve a previously-created Unpromise keyed by an original Promise. */\n  protected static getSubscribablePromise<T>(promise: PromiseLike<T>) {\n    return subscribableCache.get(promise) as ProxyPromise<T> | undefined;\n  }\n\n  /** Promise STATIC METHODS */\n\n  /** Lookup the Unpromise for this promise, and derive a SubscribedPromise from\n   * it (that can be later unsubscribed to eliminate Memory leaks) */\n  static resolve<T>(value: T | PromiseLike<T>) {\n    const promise: PromiseLike<T> =\n      typeof value === \"object\" &&\n      value !== null &&\n      \"then\" in value &&\n      typeof value.then === \"function\"\n        ? value\n        : Promise.resolve(value);\n    return Unpromise.proxy(promise).subscribe() as SubscribedPromise<\n      Awaited<T>\n    >;\n  }\n\n  /** Perform Promise.any() via SubscribedPromises, then unsubscribe them.\n   * Equivalent to Promise.any but eliminates memory leaks from long-lived\n   * promises accumulating .then() and .catch() subscribers. */\n  static async any<T extends readonly unknown[] | []>(\n    values: T\n  ): Promise<Awaited<T[number]>>;\n  static async any<T>(\n    values: Iterable<T | PromiseLike<T>>\n  ): Promise<Awaited<T>> {\n    const valuesArray = Array.isArray(values) ? values : [...values];\n    const subscribedPromises = valuesArray.map(Unpromise.resolve);\n    try {\n      return await Promise.any(subscribedPromises);\n    } finally {\n      subscribedPromises.forEach(({ unsubscribe }) => {\n        unsubscribe();\n      });\n    }\n  }\n\n  /** Perform Promise.race via SubscribedPromises, then unsubscribe them.\n   * Equivalent to Promise.race but eliminates memory leaks from long-lived\n   * promises accumulating .then() and .catch() subscribers. */\n  static async race<T extends readonly unknown[] | []>(\n    values: T\n  ): Promise<Awaited<T[number]>>;\n  static async race<T>(\n    values: Iterable<T | PromiseLike<T>>\n  ): Promise<Awaited<T>> {\n    const valuesArray = Array.isArray(values) ? values : [...values];\n    const subscribedPromises = valuesArray.map(Unpromise.resolve);\n    try {\n      return await Promise.race(subscribedPromises);\n    } finally {\n      subscribedPromises.forEach(({ unsubscribe }) => {\n        unsubscribe();\n      });\n    }\n  }\n\n  /** Create a race of SubscribedPromises that will fulfil to a single winning\n   * Promise (in a 1-Tuple). Eliminates memory leaks from long-lived promises\n   * accumulating .then() and .catch() subscribers. Allows simple logic to\n   * consume the result, like...\n   * ```ts\n   * const [ winner ] = await Unpromise.race([ promiseA, promiseB ]);\n   * if(winner === promiseB){\n   *   const result = await promiseB;\n   *   // do the thing\n   * }\n   * ```\n   * */\n  static async raceReferences<TPromise extends Promise<unknown>>(\n    promises: readonly TPromise[]\n  ) {\n    // map each promise to an eventual 1-tuple containing itself\n    const selfPromises = promises.map(resolveSelfTuple);\n\n    // now race them. They will fulfil to a readonly [P] or reject.\n    try {\n      return await Promise.race(selfPromises);\n    } finally {\n      for (const promise of selfPromises) {\n        // unsubscribe proxy promises when the race is over to mitigate memory leaks\n        promise.unsubscribe();\n      }\n    }\n  }\n}\n\n/** Promises a 1-tuple containing the original promise when it resolves. Allows\n * awaiting the eventual Promise ***reference*** (easy to destructure and\n * exactly compare with ===). Avoids resolving to the Promise ***value*** (which\n * may be ambiguous and therefore hard to identify as the winner of a race).\n * You can call unsubscribe on the Promise to mitigate memory leaks.\n * */\nexport function resolveSelfTuple<TPromise extends Promise<unknown>>(\n  promise: TPromise\n): SubscribedPromise<readonly [TPromise]> {\n  return Unpromise.proxy(promise).then(() => [promise] as const);\n}\n\n/** VENDORED (Future) PROMISE UTILITIES */\n\n/** Reference implementation of https://github.com/tc39/proposal-promise-with-resolvers */\nfunction withResolvers<T>(): PromiseWithResolvers<T> {\n  let resolve!: PromiseWithResolvers<T>[\"resolve\"];\n  let reject!: PromiseWithResolvers<T>[\"reject\"];\n  const promise = new Promise<T>((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  return {\n    promise,\n    resolve,\n    reject,\n  };\n}\n\n/** IMMUTABLE LIST OPERATIONS */\n\nfunction listWithMember<T>(arr: readonly T[], member: T): readonly T[] {\n  return [...arr, member];\n}\n\nfunction listWithoutIndex<T>(arr: readonly T[], index: number) {\n  return [...arr.slice(0, index), ...arr.slice(index + 1)];\n}\n\nfunction listWithoutMember<T>(arr: readonly T[], member: unknown) {\n  const index = arr.indexOf(member as T);\n  if (index !== -1) {\n    return listWithoutIndex(arr, index);\n  }\n  return arr;\n}\n","import type { CombinedDataTransformer } from '../unstable-core-do-not-import';\nimport type { DefaultErrorShape, ErrorFormatter } from './error/formatter';\nimport type { JSONLProducerOptions } from './stream/jsonl';\nimport type { SSEStreamProducerOptions } from './stream/sse';\n\n/**\n * The initial generics that are used in the init function\n * @internal\n */\nexport interface RootTypes {\n  ctx: object;\n  meta: object;\n  errorShape: DefaultErrorShape;\n  transformer: boolean;\n}\n\n/**\n * The default check to see if we're in a server\n */\nexport const isServerDefault: boolean =\n  typeof window === 'undefined' ||\n  'Deno' in window ||\n  // eslint-disable-next-line @typescript-eslint/dot-notation\n  globalThis.process?.env?.['NODE_ENV'] === 'test' ||\n  !!globalThis.process?.env?.['JEST_WORKER_ID'] ||\n  !!globalThis.process?.env?.['VITEST_WORKER_ID'];\n\n/**\n * The tRPC root config\n * @internal\n */\nexport interface RootConfig<TTypes extends RootTypes> {\n  /**\n   * The types that are used in the config\n   * @internal\n   */\n  $types: TTypes;\n  /**\n   * Use a data transformer\n   * @see https://trpc.io/docs/v11/data-transformers\n   */\n  transformer: CombinedDataTransformer;\n  /**\n   * Use custom error formatting\n   * @see https://trpc.io/docs/v11/error-formatting\n   */\n  errorFormatter: ErrorFormatter<TTypes['ctx'], TTypes['errorShape']>;\n  /**\n   * Allow `@trpc/server` to run in non-server environments\n   * @warning **Use with caution**, this should likely mainly be used within testing.\n   * @default false\n   */\n  allowOutsideOfServer: boolean;\n  /**\n   * Is this a server environment?\n   * @warning **Use with caution**, this should likely mainly be used within testing.\n   * @default typeof window === 'undefined' || 'Deno' in window || process.env.NODE_ENV === 'test'\n   */\n  isServer: boolean;\n  /**\n   * Is this development?\n   * Will be used to decide if the API should return stack traces\n   * @default process.env.NODE_ENV !== 'production'\n   */\n  isDev: boolean;\n\n  defaultMeta?: TTypes['meta'] extends object ? TTypes['meta'] : never;\n\n  /**\n   * Options for server-sent events (SSE) subscriptions\n   * @see https://trpc.io/docs/client/links/httpSubscriptionLink\n   */\n  sse?: {\n    /**\n     * Enable server-sent events (SSE) subscriptions\n     * @default true\n     */\n    enabled?: boolean;\n  } & Pick<\n    SSEStreamProducerOptions,\n    'ping' | 'emitAndEndImmediately' | 'maxDurationMs' | 'client'\n  >;\n\n  /**\n   * Options for batch stream\n   * @see https://trpc.io/docs/client/links/httpBatchStreamLink\n   */\n  jsonl?: Pick<JSONLProducerOptions, 'pingMs'>;\n  experimental?: {};\n}\n\n/**\n * @internal\n */\nexport type CreateRootTypes<TGenerics extends RootTypes> = TGenerics;\n\nexport type AnyRootTypes = CreateRootTypes<{\n  ctx: any;\n  meta: any;\n  errorShape: any;\n  transformer: any;\n}>;\n\ntype PartialIf<TCondition extends boolean, TType> = TCondition extends true\n  ? Partial<TType>\n  : TType;\n\n/**\n * Adds a `createContext` option with a given callback function\n * If context is the default value, then the `createContext` option is optional\n */\nexport type CreateContextCallback<\n  TContext,\n  TFunction extends (...args: any[]) => any,\n> = PartialIf<\n  object extends TContext ? true : false,\n  {\n    /**\n     * @see https://trpc.io/docs/v11/context\n     **/\n    createContext: TFunction;\n  }\n>;\n","import {\n  defaultFormatter,\n  type DefaultErrorShape,\n  type ErrorFormatter,\n} from './error/formatter';\nimport type { MiddlewareBuilder, MiddlewareFunction } from './middleware';\nimport { createMiddlewareFactory } from './middleware';\nimport type { ProcedureBuilder } from './procedureBuilder';\nimport { createBuilder } from './procedureBuilder';\nimport type { AnyRootTypes, CreateRootTypes } from './rootConfig';\nimport { isServerDefault, type RootConfig } from './rootConfig';\nimport type {\n  AnyRouter,\n  MergeRouters,\n  RouterBuilder,\n  RouterCallerFactory,\n} from './router';\nimport {\n  createCallerFactory,\n  createRouterFactory,\n  mergeRouters,\n} from './router';\nimport type { DataTransformerOptions } from './transformer';\nimport { defaultTransformer, getDataTransformer } from './transformer';\nimport type { Unwrap, ValidateShape } from './types';\nimport type { UnsetMarker } from './utils';\n\ntype inferErrorFormatterShape<TType> =\n  TType extends ErrorFormatter<any, infer TShape> ? TShape : DefaultErrorShape;\n/** @internal */\nexport interface RuntimeConfigOptions<\n  TContext extends object,\n  TMeta extends object,\n> extends Partial<\n    Omit<\n      RootConfig<{\n        ctx: TContext;\n        meta: TMeta;\n        errorShape: any;\n        transformer: any;\n      }>,\n      '$types' | 'transformer'\n    >\n  > {\n  /**\n   * Use a data transformer\n   * @see https://trpc.io/docs/v11/data-transformers\n   */\n  transformer?: DataTransformerOptions;\n}\n\ntype ContextCallback = (...args: any[]) => object | Promise<object>;\n\nexport interface TRPCRootObject<\n  TContext extends object,\n  TMeta extends object,\n  TOptions extends RuntimeConfigOptions<TContext, TMeta>,\n  $Root extends AnyRootTypes = {\n    ctx: TContext;\n    meta: TMeta;\n    errorShape: undefined extends TOptions['errorFormatter']\n      ? DefaultErrorShape\n      : inferErrorFormatterShape<TOptions['errorFormatter']>;\n    transformer: undefined extends TOptions['transformer'] ? false : true;\n  },\n> {\n  /**\n   * Your router config\n   * @internal\n   */\n  _config: RootConfig<$Root>;\n\n  /**\n   * Builder object for creating procedures\n   * @see https://trpc.io/docs/v11/server/procedures\n   */\n  procedure: ProcedureBuilder<\n    TContext,\n    TMeta,\n    object,\n    UnsetMarker,\n    UnsetMarker,\n    UnsetMarker,\n    UnsetMarker,\n    false\n  >;\n\n  /**\n   * Create reusable middlewares\n   * @see https://trpc.io/docs/v11/server/middlewares\n   */\n  middleware: <$ContextOverrides>(\n    fn: MiddlewareFunction<TContext, TMeta, object, $ContextOverrides, unknown>,\n  ) => MiddlewareBuilder<TContext, TMeta, $ContextOverrides, unknown>;\n\n  /**\n   * Create a router\n   * @see https://trpc.io/docs/v11/server/routers\n   */\n  router: RouterBuilder<$Root>;\n\n  /**\n   * Merge Routers\n   * @see https://trpc.io/docs/v11/server/merging-routers\n   */\n  mergeRouters: <TRouters extends AnyRouter[]>(\n    ...routerList: [...TRouters]\n  ) => MergeRouters<TRouters>;\n\n  /**\n   * Create a server-side caller for a router\n   * @see https://trpc.io/docs/v11/server/server-side-calls\n   */\n  createCallerFactory: RouterCallerFactory<$Root>;\n}\n\nclass TRPCBuilder<TContext extends object, TMeta extends object> {\n  /**\n   * Add a context shape as a generic to the root object\n   * @see https://trpc.io/docs/v11/server/context\n   */\n  context<TNewContext extends object | ContextCallback>() {\n    return new TRPCBuilder<\n      TNewContext extends ContextCallback ? Unwrap<TNewContext> : TNewContext,\n      TMeta\n    >();\n  }\n\n  /**\n   * Add a meta shape as a generic to the root object\n   * @see https://trpc.io/docs/v11/quickstart\n   */\n  meta<TNewMeta extends object>() {\n    return new TRPCBuilder<TContext, TNewMeta>();\n  }\n\n  /**\n   * Create the root object\n   * @see https://trpc.io/docs/v11/server/routers#initialize-trpc\n   */\n  create<TOptions extends RuntimeConfigOptions<TContext, TMeta>>(\n    opts?: ValidateShape<TOptions, RuntimeConfigOptions<TContext, TMeta>>,\n  ): TRPCRootObject<TContext, TMeta, TOptions> {\n    type $Root = CreateRootTypes<{\n      ctx: TContext;\n      meta: TMeta;\n      errorShape: undefined extends TOptions['errorFormatter']\n        ? DefaultErrorShape\n        : inferErrorFormatterShape<TOptions['errorFormatter']>;\n      transformer: undefined extends TOptions['transformer'] ? false : true;\n    }>;\n\n    const config: RootConfig<$Root> = {\n      ...opts,\n      transformer: getDataTransformer(opts?.transformer ?? defaultTransformer),\n      isDev:\n        opts?.isDev ??\n        // eslint-disable-next-line @typescript-eslint/dot-notation\n        globalThis.process?.env['NODE_ENV'] !== 'production',\n      allowOutsideOfServer: opts?.allowOutsideOfServer ?? false,\n      errorFormatter: opts?.errorFormatter ?? defaultFormatter,\n      isServer: opts?.isServer ?? isServerDefault,\n      /**\n       * These are just types, they can't be used at runtime\n       * @internal\n       */\n      $types: null as any,\n    };\n\n    {\n      // Server check\n      const isServer: boolean = opts?.isServer ?? isServerDefault;\n\n      if (!isServer && opts?.allowOutsideOfServer !== true) {\n        throw new Error(\n          `You're trying to use @trpc/server in a non-server environment. This is not supported by default.`,\n        );\n      }\n    }\n    return {\n      /**\n       * Your router config\n       * @internal\n       */\n      _config: config,\n      /**\n       * Builder object for creating procedures\n       * @see https://trpc.io/docs/v11/server/procedures\n       */\n      procedure: createBuilder<$Root['ctx'], $Root['meta']>({\n        meta: opts?.defaultMeta,\n      }),\n      /**\n       * Create reusable middlewares\n       * @see https://trpc.io/docs/v11/server/middlewares\n       */\n      middleware: createMiddlewareFactory<$Root['ctx'], $Root['meta']>(),\n      /**\n       * Create a router\n       * @see https://trpc.io/docs/v11/server/routers\n       */\n      router: createRouterFactory<$Root>(config),\n      /**\n       * Merge Routers\n       * @see https://trpc.io/docs/v11/server/merging-routers\n       */\n      mergeRouters,\n      /**\n       * Create a server-side caller for a router\n       * @see https://trpc.io/docs/v11/server/server-side-calls\n       */\n      createCallerFactory: createCallerFactory<$Root>(),\n    };\n  }\n}\n\n/**\n * Builder to initialize the tRPC root object - use this exactly once per backend\n * @see https://trpc.io/docs/v11/quickstart\n */\nexport const initTRPC = new TRPCBuilder();\nexport type { TRPCBuilder };\n","const trackedSymbol = Symbol();\n\ntype TrackedId = string & {\n  __brand: 'TrackedId';\n};\nexport type TrackedEnvelope<TData> = [TrackedId, TData, typeof trackedSymbol];\n\nexport interface TrackedData<TData> {\n  /**\n   * The id of the message to keep track of in case the connection gets lost\n   */\n  id: string;\n  /**\n   * The data field of the message\n   */\n  data: TData;\n}\n/**\n * Produce a typed server-sent event message\n * @deprecated use `tracked(id, data)` instead\n */\nexport function sse<TData>(event: { id: string; data: TData }) {\n  return tracked(event.id, event.data);\n}\n\nexport function isTrackedEnvelope<TData>(\n  value: unknown,\n): value is TrackedEnvelope<TData> {\n  return Array.isArray(value) && value[2] === trackedSymbol;\n}\n\n/**\n * Automatically track an event so that it can be resumed from a given id if the connection is lost\n */\nexport function tracked<TData>(\n  id: string,\n  data: TData,\n): TrackedEnvelope<TData> {\n  if (id === '') {\n    // This limitation could be removed by using different SSE event names / channels for tracked event and non-tracked event\n    throw new Error(\n      '`id` must not be an empty string as empty string is the same as not setting the id at all',\n    );\n  }\n  return [id as TrackedId, data, trackedSymbol];\n}\n\nexport type inferTrackedOutput<TData> =\n  TData extends TrackedEnvelope<infer $Data> ? TrackedData<$Data> : TData;\n","// @ts-expect-error - polyfilling symbol\n// eslint-disable-next-line no-restricted-syntax\nSymbol.dispose ??= Symbol();\n\n// @ts-expect-error - polyfilling symbol\n// eslint-disable-next-line no-restricted-syntax\nSymbol.asyncDispose ??= Symbol();\n\n/**\n * Takes a value and a dispose function and returns a new object that implements the Disposable interface.\n * The returned object is the original value augmented with a Symbol.dispose method.\n * @param thing The value to make disposable\n * @param dispose Function to call when disposing the resource\n * @returns The original value with Symbol.dispose method added\n */\nexport function makeResource<T>(thing: T, dispose: () => void): T & Disposable {\n  const it = thing as T & Partial<Disposable>;\n\n  // eslint-disable-next-line no-restricted-syntax\n  const existing = it[Symbol.dispose];\n\n  // eslint-disable-next-line no-restricted-syntax\n  it[Symbol.dispose] = () => {\n    dispose();\n    existing?.();\n  };\n\n  return it as T & Disposable;\n}\n\n/**\n * Takes a value and an async dispose function and returns a new object that implements the AsyncDisposable interface.\n * The returned object is the original value augmented with a Symbol.asyncDispose method.\n * @param thing The value to make async disposable\n * @param dispose Async function to call when disposing the resource\n * @returns The original value with Symbol.asyncDispose method added\n */\nexport function makeAsyncResource<T>(\n  thing: T,\n  dispose: () => Promise<void>,\n): T & AsyncDisposable {\n  const it = thing as T & Partial<AsyncDisposable>;\n\n  // eslint-disable-next-line no-restricted-syntax\n  const existing = it[Symbol.asyncDispose];\n\n  // eslint-disable-next-line no-restricted-syntax\n  it[Symbol.asyncDispose] = async () => {\n    await dispose();\n    await existing?.();\n  };\n\n  return it as T & AsyncDisposable;\n}\n","import { makeResource } from './disposable';\n\nexport const disposablePromiseTimerResult = Symbol();\n\nexport function timerResource(ms: number) {\n  let timer: ReturnType<typeof setTimeout> | null = null;\n\n  return makeResource(\n    {\n      start() {\n        if (timer) {\n          throw new Error('Timer already started');\n        }\n\n        const promise = new Promise<typeof disposablePromiseTimerResult>(\n          (resolve) => {\n            timer = setTimeout(() => resolve(disposablePromiseTimerResult), ms);\n          },\n        );\n        return promise;\n      },\n    },\n    () => {\n      if (timer) {\n        clearTimeout(timer);\n      }\n    },\n  );\n}\n","function _usingCtx() {\n  var r = \"function\" == typeof SuppressedError ? SuppressedError : function (r, e) {\n      var n = Error();\n      return n.name = \"SuppressedError\", n.error = r, n.suppressed = e, n;\n    },\n    e = {},\n    n = [];\n  function using(r, e) {\n    if (null != e) {\n      if (Object(e) !== e) throw new TypeError(\"using declarations can only be used with objects, functions, null, or undefined.\");\n      if (r) var o = e[Symbol.asyncDispose || Symbol[\"for\"](\"Symbol.asyncDispose\")];\n      if (void 0 === o && (o = e[Symbol.dispose || Symbol[\"for\"](\"Symbol.dispose\")], r)) var t = o;\n      if (\"function\" != typeof o) throw new TypeError(\"Object is not disposable.\");\n      t && (o = function o() {\n        try {\n          t.call(e);\n        } catch (r) {\n          return Promise.reject(r);\n        }\n      }), n.push({\n        v: e,\n        d: o,\n        a: r\n      });\n    } else r && n.push({\n      d: e,\n      a: r\n    });\n    return e;\n  }\n  return {\n    e: e,\n    u: using.bind(null, !1),\n    a: using.bind(null, !0),\n    d: function d() {\n      var o,\n        t = this.e,\n        s = 0;\n      function next() {\n        for (; o = n.pop();) try {\n          if (!o.a && 1 === s) return s = 0, n.push(o), Promise.resolve().then(next);\n          if (o.d) {\n            var r = o.d.call(o.v);\n            if (o.a) return s |= 2, Promise.resolve(r).then(next, err);\n          } else s |= 1;\n        } catch (r) {\n          return err(r);\n        }\n        if (1 === s) return t !== e ? Promise.reject(t) : Promise.resolve();\n        if (t !== e) throw t;\n      }\n      function err(n) {\n        return t = t !== e ? new r(n, t) : n, next();\n      }\n      return next();\n    }\n  };\n}\nmodule.exports = _usingCtx, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _OverloadYield(e, d) {\n  this.v = e, this.k = d;\n}\nmodule.exports = _OverloadYield, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var OverloadYield = require(\"./OverloadYield.js\");\nfunction _awaitAsyncGenerator(e) {\n  return new OverloadYield(e, 0);\n}\nmodule.exports = _awaitAsyncGenerator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var OverloadYield = require(\"./OverloadYield.js\");\nfunction _wrapAsyncGenerator(e) {\n  return function () {\n    return new AsyncGenerator(e.apply(this, arguments));\n  };\n}\nfunction AsyncGenerator(e) {\n  var r, t;\n  function resume(r, t) {\n    try {\n      var n = e[r](t),\n        o = n.value,\n        u = o instanceof OverloadYield;\n      Promise.resolve(u ? o.v : o).then(function (t) {\n        if (u) {\n          var i = \"return\" === r ? \"return\" : \"next\";\n          if (!o.k || t.done) return resume(i, t);\n          t = e[i](t).value;\n        }\n        settle(n.done ? \"return\" : \"normal\", t);\n      }, function (e) {\n        resume(\"throw\", e);\n      });\n    } catch (e) {\n      settle(\"throw\", e);\n    }\n  }\n  function settle(e, n) {\n    switch (e) {\n      case \"return\":\n        r.resolve({\n          value: n,\n          done: !0\n        });\n        break;\n      case \"throw\":\n        r.reject(n);\n        break;\n      default:\n        r.resolve({\n          value: n,\n          done: !1\n        });\n    }\n    (r = r.next) ? resume(r.key, r.arg) : t = null;\n  }\n  this._invoke = function (e, n) {\n    return new Promise(function (o, u) {\n      var i = {\n        key: e,\n        arg: n,\n        resolve: o,\n        reject: u,\n        next: null\n      };\n      t ? t = t.next = i : (r = t = i, resume(e, n));\n    });\n  }, \"function\" != typeof e[\"return\"] && (this[\"return\"] = void 0);\n}\nAsyncGenerator.prototype[\"function\" == typeof Symbol && Symbol.asyncIterator || \"@@asyncIterator\"] = function () {\n  return this;\n}, AsyncGenerator.prototype.next = function (e) {\n  return this._invoke(\"next\", e);\n}, AsyncGenerator.prototype[\"throw\"] = function (e) {\n  return this._invoke(\"throw\", e);\n}, AsyncGenerator.prototype[\"return\"] = function (e) {\n  return this._invoke(\"return\", e);\n};\nmodule.exports = _wrapAsyncGenerator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import { Unpromise } from '../../../vendor/unpromise';\nimport { throwAbortError } from '../../http/abortError';\nimport { makeAsyncResource } from './disposable';\nimport { disposablePromiseTimerResult, timerResource } from './timerResource';\n\nexport function iteratorResource<TYield, TReturn, TNext>(\n  iterable: AsyncIterable<TYield, TReturn, TNext>,\n): AsyncIterator<TYield, TReturn, TNext> & AsyncDisposable {\n  const iterator = iterable[Symbol.asyncIterator]();\n\n  // @ts-expect-error - this is added in node 24 which we don't officially support yet\n  // eslint-disable-next-line no-restricted-syntax\n  if (iterator[Symbol.asyncDispose]) {\n    return iterator as AsyncIterator<TYield, TReturn, TNext> & AsyncDisposable;\n  }\n\n  return makeAsyncResource(iterator, async () => {\n    await iterator.return?.();\n  });\n}\n\n/**\n * Derives a new {@link AsyncGenerator} based of {@link iterable}, that yields its first\n * {@link count} values. Then, a grace period of {@link gracePeriodMs} is started in which further\n * values may still come through. After this period, the generator aborts.\n */\nexport async function* takeWithGrace<T>(\n  iterable: AsyncIterable<T>,\n  opts: {\n    count: number;\n    gracePeriodMs: number;\n  },\n): AsyncGenerator<T> {\n  await using iterator = iteratorResource(iterable);\n\n  // declaration outside the loop for garbage collection reasons\n  let result: null | IteratorResult<T> | typeof disposablePromiseTimerResult;\n\n  using timer = timerResource(opts.gracePeriodMs);\n\n  let count = opts.count;\n\n  let timerPromise = new Promise<typeof disposablePromiseTimerResult>(() => {\n    // never resolves\n  });\n\n  while (true) {\n    result = await Unpromise.race([iterator.next(), timerPromise]);\n    if (result === disposablePromiseTimerResult) {\n      throwAbortError();\n    }\n    if (result.done) {\n      return result.value;\n    }\n    yield result.value;\n    if (--count === 0) {\n      timerPromise = timer.start();\n    }\n    // free up reference for garbage collection\n    result = null;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nexport function createDeferred<TValue = void>() {\n  let resolve: (value: TValue) => void;\n  let reject: (error: unknown) => void;\n  const promise = new Promise<TValue>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return { promise, resolve: resolve!, reject: reject! };\n}\nexport type Deferred<TValue> = ReturnType<typeof createDeferred<TValue>>;\n","import { createDeferred } from './createDeferred';\nimport { makeAsyncResource } from './disposable';\n\ntype ManagedIteratorResult<TYield, TReturn> =\n  | { status: 'yield'; value: TYield }\n  | { status: 'return'; value: TReturn }\n  | { status: 'error'; error: unknown };\nfunction createManagedIterator<TYield, TReturn>(\n  iterable: AsyncIterable<TYield, TReturn>,\n  onResult: (result: ManagedIteratorResult<TYield, TReturn>) => void,\n) {\n  const iterator = iterable[Symbol.asyncIterator]();\n  let state: 'idle' | 'pending' | 'done' = 'idle';\n\n  function cleanup() {\n    state = 'done';\n    onResult = () => {\n      // noop\n    };\n  }\n\n  function pull() {\n    if (state !== 'idle') {\n      return;\n    }\n    state = 'pending';\n\n    const next = iterator.next();\n    next\n      .then((result) => {\n        if (result.done) {\n          state = 'done';\n          onResult({ status: 'return', value: result.value });\n          cleanup();\n          return;\n        }\n        state = 'idle';\n        onResult({ status: 'yield', value: result.value });\n      })\n      .catch((cause) => {\n        onResult({ status: 'error', error: cause });\n        cleanup();\n      });\n  }\n\n  return {\n    pull,\n    destroy: async () => {\n      cleanup();\n      await iterator.return?.();\n    },\n  };\n}\ntype ManagedIterator<TYield, TReturn> = ReturnType<\n  typeof createManagedIterator<TYield, TReturn>\n>;\n\ninterface MergedAsyncIterables<TYield>\n  extends AsyncIterable<TYield, void, unknown> {\n  add(iterable: AsyncIterable<TYield>): void;\n}\n\n/**\n * Creates a new async iterable that merges multiple async iterables into a single stream.\n * Values from the input iterables are yielded in the order they resolve, similar to Promise.race().\n *\n * New iterables can be added dynamically using the returned {@link MergedAsyncIterables.add} method, even after iteration has started.\n *\n * If any of the input iterables throws an error, that error will be propagated through the merged stream.\n * Other iterables will not continue to be processed.\n *\n * @template TYield The type of values yielded by the input iterables\n */\nexport function mergeAsyncIterables<TYield>(): MergedAsyncIterables<TYield> {\n  let state: 'idle' | 'pending' | 'done' = 'idle';\n  let flushSignal = createDeferred();\n\n  /**\n   * used while {@link state} is `idle`\n   */\n  const iterables: AsyncIterable<TYield, void, unknown>[] = [];\n  /**\n   * used while {@link state} is `pending`\n   */\n  const iterators = new Set<ManagedIterator<TYield, void>>();\n\n  const buffer: Array<\n    [\n      iterator: ManagedIterator<TYield, void>,\n      result: Exclude<\n        ManagedIteratorResult<TYield, void>,\n        { status: 'return' }\n      >,\n    ]\n  > = [];\n\n  function initIterable(iterable: AsyncIterable<TYield, void, unknown>) {\n    if (state !== 'pending') {\n      // shouldn't happen\n      return;\n    }\n    const iterator = createManagedIterator(iterable, (result) => {\n      if (state !== 'pending') {\n        // shouldn't happen\n        return;\n      }\n      switch (result.status) {\n        case 'yield':\n          buffer.push([iterator, result]);\n          break;\n        case 'return':\n          iterators.delete(iterator);\n          break;\n        case 'error':\n          buffer.push([iterator, result]);\n          iterators.delete(iterator);\n          break;\n      }\n      flushSignal.resolve();\n    });\n    iterators.add(iterator);\n    iterator.pull();\n  }\n\n  return {\n    add(iterable: AsyncIterable<TYield, void, unknown>) {\n      switch (state) {\n        case 'idle':\n          iterables.push(iterable);\n          break;\n        case 'pending':\n          initIterable(iterable);\n          break;\n        case 'done': {\n          // shouldn't happen\n          break;\n        }\n      }\n    },\n    async *[Symbol.asyncIterator]() {\n      if (state !== 'idle') {\n        throw new Error('Cannot iterate twice');\n      }\n      state = 'pending';\n\n      await using _finally = makeAsyncResource({}, async () => {\n        state = 'done';\n\n        const errors: unknown[] = [];\n        await Promise.all(\n          Array.from(iterators.values()).map(async (it) => {\n            try {\n              await it.destroy();\n            } catch (cause) {\n              errors.push(cause);\n            }\n          }),\n        );\n        buffer.length = 0;\n        iterators.clear();\n        flushSignal.resolve();\n\n        if (errors.length > 0) {\n          throw new AggregateError(errors);\n        }\n      });\n\n      while (iterables.length > 0) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        initIterable(iterables.shift()!);\n      }\n\n      while (iterators.size > 0) {\n        await flushSignal.promise;\n\n        while (buffer.length > 0) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const [iterator, result] = buffer.shift()!;\n\n          switch (result.status) {\n            case 'yield':\n              yield result.value;\n              iterator.pull();\n              break;\n            case 'error':\n              throw result.error;\n          }\n        }\n        flushSignal = createDeferred();\n      }\n    },\n  };\n}\n","/**\n * Creates a ReadableStream from an AsyncIterable.\n *\n * @param iterable - The source AsyncIterable to stream from\n * @returns A ReadableStream that yields values from the AsyncIterable\n */\nexport function readableStreamFrom<TYield>(\n  iterable: AsyncIterable<TYield, void>,\n): ReadableStream<TYield> {\n  const iterator = iterable[Symbol.asyncIterator]();\n\n  return new ReadableStream({\n    async cancel() {\n      await iterator.return?.();\n    },\n\n    async pull(controller) {\n      const result = await iterator.next();\n\n      if (result.done) {\n        controller.close();\n        return;\n      }\n\n      controller.enqueue(result.value);\n    },\n  });\n}\n","import { Unpromise } from '../../../vendor/unpromise';\nimport { iteratorResource } from './asyncIterable';\nimport { disposablePromiseTimerResult, timerResource } from './timerResource';\n\nexport const PING_SYM = Symbol('ping');\n\n/**\n * Derives a new {@link AsyncGenerator} based of {@link iterable}, that yields {@link PING_SYM}\n * whenever no value has been yielded for {@link pingIntervalMs}.\n */\nexport async function* withPing<TValue>(\n  iterable: AsyncIterable<TValue>,\n  pingIntervalMs: number,\n): AsyncGenerator<TValue | typeof PING_SYM> {\n  await using iterator = iteratorResource(iterable);\n\n  // declaration outside the loop for garbage collection reasons\n  let result:\n    | null\n    | IteratorResult<TValue>\n    | typeof disposablePromiseTimerResult;\n\n  let nextPromise = iterator.next();\n\n  while (true) {\n    using pingPromise = timerResource(pingIntervalMs);\n\n    result = await Unpromise.race([nextPromise, pingPromise.start()]);\n\n    if (result === disposablePromiseTimerResult) {\n      // cancelled\n\n      yield PING_SYM;\n      continue;\n    }\n\n    if (result.done) {\n      return result.value;\n    }\n\n    nextPromise = iterator.next();\n    yield result.value;\n\n    // free up reference for garbage collection\n    result = null;\n  }\n}\n","function _asyncIterator(r) {\n  var n,\n    t,\n    o,\n    e = 2;\n  for (\"undefined\" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) {\n    if (t && null != (n = r[t])) return n.call(r);\n    if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r));\n    t = \"@@asyncIterator\", o = \"@@iterator\";\n  }\n  throw new TypeError(\"Object is not async iterable\");\n}\nfunction AsyncFromSyncIterator(r) {\n  function AsyncFromSyncIteratorContinuation(r) {\n    if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\"));\n    var n = r.done;\n    return Promise.resolve(r.value).then(function (r) {\n      return {\n        value: r,\n        done: n\n      };\n    });\n  }\n  return AsyncFromSyncIterator = function AsyncFromSyncIterator(r) {\n    this.s = r, this.n = r.next;\n  }, AsyncFromSyncIterator.prototype = {\n    s: null,\n    n: null,\n    next: function next() {\n      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));\n    },\n    \"return\": function _return(r) {\n      var n = this.s[\"return\"];\n      return void 0 === n ? Promise.resolve({\n        value: r,\n        done: !0\n      }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n    },\n    \"throw\": function _throw(r) {\n      var n = this.s[\"return\"];\n      return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n    }\n  }, new AsyncFromSyncIterator(r);\n}\nmodule.exports = _asyncIterator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import { isPlainObject } from '@trpc/server/vendor/is-plain-object';\nimport {\n  emptyObject,\n  isAsyncIterable,\n  isFunction,\n  isObject,\n  run,\n} from '../utils';\nimport { iteratorResource } from './utils/asyncIterable';\nimport type { Deferred } from './utils/createDeferred';\nimport { createDeferred } from './utils/createDeferred';\nimport { makeResource } from './utils/disposable';\nimport { mergeAsyncIterables } from './utils/mergeAsyncIterables';\nimport { readableStreamFrom } from './utils/readableStreamFrom';\nimport { PING_SYM, withPing } from './utils/withPing';\n\n/**\n * A subset of the standard ReadableStream properties needed by tRPC internally.\n * @see ReadableStream from lib.dom.d.ts\n */\nexport type WebReadableStreamEsque = {\n  getReader: () => ReadableStreamDefaultReader<Uint8Array>;\n};\n\nexport type NodeJSReadableStreamEsque = {\n  on(\n    eventName: string | symbol,\n    listener: (...args: any[]) => void,\n  ): NodeJSReadableStreamEsque;\n};\n\n// ---------- types\nconst CHUNK_VALUE_TYPE_PROMISE = 0;\ntype CHUNK_VALUE_TYPE_PROMISE = typeof CHUNK_VALUE_TYPE_PROMISE;\nconst CHUNK_VALUE_TYPE_ASYNC_ITERABLE = 1;\ntype CHUNK_VALUE_TYPE_ASYNC_ITERABLE = typeof CHUNK_VALUE_TYPE_ASYNC_ITERABLE;\n\nconst PROMISE_STATUS_FULFILLED = 0;\ntype PROMISE_STATUS_FULFILLED = typeof PROMISE_STATUS_FULFILLED;\nconst PROMISE_STATUS_REJECTED = 1;\ntype PROMISE_STATUS_REJECTED = typeof PROMISE_STATUS_REJECTED;\n\nconst ASYNC_ITERABLE_STATUS_RETURN = 0;\ntype ASYNC_ITERABLE_STATUS_RETURN = typeof ASYNC_ITERABLE_STATUS_RETURN;\nconst ASYNC_ITERABLE_STATUS_YIELD = 1;\ntype ASYNC_ITERABLE_STATUS_YIELD = typeof ASYNC_ITERABLE_STATUS_YIELD;\nconst ASYNC_ITERABLE_STATUS_ERROR = 2;\ntype ASYNC_ITERABLE_STATUS_ERROR = typeof ASYNC_ITERABLE_STATUS_ERROR;\n\ntype ChunkDefinitionKey =\n  // root should be replaced\n  | null\n  // at array path\n  | number\n  // at key path\n  | string;\n\ntype ChunkIndex = number & { __chunkIndex: true };\ntype ChunkValueType =\n  | CHUNK_VALUE_TYPE_PROMISE\n  | CHUNK_VALUE_TYPE_ASYNC_ITERABLE;\ntype ChunkDefinition = [\n  key: ChunkDefinitionKey,\n  type: ChunkValueType,\n  chunkId: ChunkIndex,\n];\ntype EncodedValue = [\n  // data\n  [unknown] | [],\n  // chunk descriptions\n  ...ChunkDefinition[],\n];\n\ntype Head = Record<string, EncodedValue>;\ntype PromiseChunk =\n  | [\n      chunkIndex: ChunkIndex,\n      status: PROMISE_STATUS_FULFILLED,\n      value: EncodedValue,\n    ]\n  | [chunkIndex: ChunkIndex, status: PROMISE_STATUS_REJECTED, error: unknown];\ntype IterableChunk =\n  | [\n      chunkIndex: ChunkIndex,\n      status: ASYNC_ITERABLE_STATUS_RETURN,\n      value: EncodedValue,\n    ]\n  | [\n      chunkIndex: ChunkIndex,\n      status: ASYNC_ITERABLE_STATUS_YIELD,\n      value: EncodedValue,\n    ]\n  | [\n      chunkIndex: ChunkIndex,\n      status: ASYNC_ITERABLE_STATUS_ERROR,\n      error: unknown,\n    ];\ntype ChunkData = PromiseChunk | IterableChunk;\ntype PlaceholderValue = 0 & { __placeholder: true };\nexport function isPromise(value: unknown): value is Promise<unknown> {\n  return (\n    (isObject(value) || isFunction(value)) &&\n    typeof value?.['then'] === 'function' &&\n    typeof value?.['catch'] === 'function'\n  );\n}\n\ntype Serialize = (value: any) => any;\ntype Deserialize = (value: any) => any;\n\ntype PathArray = readonly (string | number)[];\nexport type ProducerOnError = (opts: {\n  error: unknown;\n  path: PathArray;\n}) => void;\nexport interface JSONLProducerOptions {\n  serialize?: Serialize;\n  data: Record<string, unknown> | unknown[];\n  onError?: ProducerOnError;\n  formatError?: (opts: { error: unknown; path: PathArray }) => unknown;\n  maxDepth?: number;\n  /**\n   * Interval in milliseconds to send a ping to the client to keep the connection alive\n   * This will be sent as a whitespace character\n   * @default undefined\n   */\n  pingMs?: number;\n}\n\nclass MaxDepthError extends Error {\n  constructor(public path: (string | number)[]) {\n    super('Max depth reached at path: ' + path.join('.'));\n  }\n}\n\nasync function* createBatchStreamProducer(\n  opts: JSONLProducerOptions,\n): AsyncIterable<Head | ChunkData | typeof PING_SYM, void> {\n  const { data } = opts;\n  let counter = 0 as ChunkIndex;\n  const placeholder = 0 as PlaceholderValue;\n\n  const mergedIterables = mergeAsyncIterables<ChunkData>();\n  function registerAsync(\n    callback: (idx: ChunkIndex) => AsyncIterable<ChunkData, void>,\n  ) {\n    const idx = counter++ as ChunkIndex;\n\n    const iterable = callback(idx);\n    mergedIterables.add(iterable);\n\n    return idx;\n  }\n\n  function encodePromise(promise: Promise<unknown>, path: (string | number)[]) {\n    return registerAsync(async function* (idx) {\n      const error = checkMaxDepth(path);\n      if (error) {\n        // Catch any errors from the original promise to ensure they're reported\n        promise.catch((cause) => {\n          opts.onError?.({ error: cause, path });\n        });\n        // Replace the promise with a rejected one containing the max depth error\n        promise = Promise.reject(error);\n      }\n      try {\n        const next = await promise;\n        yield [idx, PROMISE_STATUS_FULFILLED, encode(next, path)];\n      } catch (cause) {\n        opts.onError?.({ error: cause, path });\n        yield [\n          idx,\n          PROMISE_STATUS_REJECTED,\n          opts.formatError?.({ error: cause, path }),\n        ];\n      }\n    });\n  }\n  function encodeAsyncIterable(\n    iterable: AsyncIterable<unknown>,\n    path: (string | number)[],\n  ) {\n    return registerAsync(async function* (idx) {\n      const error = checkMaxDepth(path);\n      if (error) {\n        throw error;\n      }\n      await using iterator = iteratorResource(iterable);\n\n      try {\n        while (true) {\n          const next = await iterator.next();\n          if (next.done) {\n            yield [idx, ASYNC_ITERABLE_STATUS_RETURN, encode(next.value, path)];\n            break;\n          }\n          yield [idx, ASYNC_ITERABLE_STATUS_YIELD, encode(next.value, path)];\n        }\n      } catch (cause) {\n        opts.onError?.({ error: cause, path });\n\n        yield [\n          idx,\n          ASYNC_ITERABLE_STATUS_ERROR,\n          opts.formatError?.({ error: cause, path }),\n        ];\n      }\n    });\n  }\n  function checkMaxDepth(path: (string | number)[]) {\n    if (opts.maxDepth && path.length > opts.maxDepth) {\n      return new MaxDepthError(path);\n    }\n    return null;\n  }\n  function encodeAsync(\n    value: unknown,\n    path: (string | number)[],\n  ): null | [type: ChunkValueType, chunkId: ChunkIndex] {\n    if (isPromise(value)) {\n      return [CHUNK_VALUE_TYPE_PROMISE, encodePromise(value, path)];\n    }\n    if (isAsyncIterable(value)) {\n      if (opts.maxDepth && path.length >= opts.maxDepth) {\n        throw new Error('Max depth reached');\n      }\n      return [\n        CHUNK_VALUE_TYPE_ASYNC_ITERABLE,\n        encodeAsyncIterable(value, path),\n      ];\n    }\n    return null;\n  }\n  function encode(value: unknown, path: (string | number)[]): EncodedValue {\n    if (value === undefined) {\n      return [[]];\n    }\n    const reg = encodeAsync(value, path);\n    if (reg) {\n      return [[placeholder], [null, ...reg]];\n    }\n\n    if (!isPlainObject(value)) {\n      return [[value]];\n    }\n\n    const newObj: Record<string, unknown> = emptyObject();\n    const asyncValues: ChunkDefinition[] = [];\n    for (const [key, item] of Object.entries(value)) {\n      const transformed = encodeAsync(item, [...path, key]);\n      if (!transformed) {\n        newObj[key] = item;\n        continue;\n      }\n      newObj[key] = placeholder;\n      asyncValues.push([key, ...transformed]);\n    }\n    return [[newObj], ...asyncValues];\n  }\n\n  const newHead: Head = emptyObject();\n  for (const [key, item] of Object.entries(data)) {\n    newHead[key] = encode(item, [key]);\n  }\n\n  yield newHead;\n\n  let iterable: AsyncIterable<ChunkData | typeof PING_SYM, void> =\n    mergedIterables;\n  if (opts.pingMs) {\n    iterable = withPing(mergedIterables, opts.pingMs);\n  }\n\n  for await (const value of iterable) {\n    yield value;\n  }\n}\n/**\n * JSON Lines stream producer\n * @see https://jsonlines.org/\n */\nexport function jsonlStreamProducer(opts: JSONLProducerOptions) {\n  let stream = readableStreamFrom(createBatchStreamProducer(opts));\n\n  const { serialize } = opts;\n  if (serialize) {\n    stream = stream.pipeThrough(\n      new TransformStream({\n        transform(chunk, controller) {\n          if (chunk === PING_SYM) {\n            controller.enqueue(PING_SYM);\n          } else {\n            controller.enqueue(serialize(chunk));\n          }\n        },\n      }),\n    );\n  }\n\n  return stream\n    .pipeThrough(\n      new TransformStream({\n        transform(chunk, controller) {\n          if (chunk === PING_SYM) {\n            controller.enqueue(' ');\n          } else {\n            controller.enqueue(JSON.stringify(chunk) + '\\n');\n          }\n        },\n      }),\n    )\n    .pipeThrough(new TextEncoderStream());\n}\n\nclass AsyncError extends Error {\n  constructor(public readonly data: unknown) {\n    super('Received error from server');\n  }\n}\nexport type ConsumerOnError = (opts: { error: unknown }) => void;\n\nconst nodeJsStreamToReaderEsque = (source: NodeJSReadableStreamEsque) => {\n  return {\n    getReader() {\n      const stream = new ReadableStream<Uint8Array>({\n        start(controller) {\n          source.on('data', (chunk) => {\n            controller.enqueue(chunk);\n          });\n          source.on('end', () => {\n            controller.close();\n          });\n          source.on('error', (error) => {\n            controller.error(error);\n          });\n        },\n      });\n      return stream.getReader();\n    },\n  };\n};\n\nfunction createLineAccumulator(\n  from: NodeJSReadableStreamEsque | WebReadableStreamEsque,\n) {\n  const reader =\n    'getReader' in from\n      ? from.getReader()\n      : nodeJsStreamToReaderEsque(from).getReader();\n\n  let lineAggregate = '';\n\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await reader.read();\n\n      if (done) {\n        controller.close();\n      } else {\n        controller.enqueue(value);\n      }\n    },\n    cancel() {\n      return reader.cancel();\n    },\n  })\n    .pipeThrough(new TextDecoderStream())\n    .pipeThrough(\n      new TransformStream<string, string>({\n        transform(chunk, controller) {\n          lineAggregate += chunk;\n          const parts = lineAggregate.split('\\n');\n          lineAggregate = parts.pop() ?? '';\n          for (const part of parts) {\n            controller.enqueue(part);\n          }\n        },\n      }),\n    );\n}\nfunction createConsumerStream<THead>(\n  from: NodeJSReadableStreamEsque | WebReadableStreamEsque,\n) {\n  const stream = createLineAccumulator(from);\n\n  let sentHead = false;\n  return stream.pipeThrough(\n    new TransformStream<string, ChunkData | THead>({\n      transform(line, controller) {\n        if (!sentHead) {\n          const head = JSON.parse(line);\n          controller.enqueue(head as THead);\n          sentHead = true;\n        } else {\n          const chunk: ChunkData = JSON.parse(line);\n          controller.enqueue(chunk);\n        }\n      },\n    }),\n  );\n}\n\n/**\n * Creates a handler for managing stream controllers and their lifecycle\n */\nfunction createStreamsManager(abortController: AbortController) {\n  const controllerMap = new Map<\n    ChunkIndex,\n    ReturnType<typeof createStreamController>\n  >();\n\n  /**\n   * Checks if there are no pending controllers or deferred promises\n   */\n  function isEmpty() {\n    return Array.from(controllerMap.values()).every((c) => c.closed);\n  }\n\n  /**\n   * Creates a stream controller\n   */\n  function createStreamController() {\n    let originalController: ReadableStreamDefaultController<ChunkData>;\n    const stream = new ReadableStream<ChunkData>({\n      start(controller) {\n        originalController = controller;\n      },\n    });\n\n    const streamController = {\n      enqueue: (v: ChunkData) => originalController.enqueue(v),\n      close: () => {\n        originalController.close();\n\n        clear();\n\n        if (isEmpty()) {\n          abortController.abort();\n        }\n      },\n      closed: false,\n      getReaderResource: () => {\n        const reader = stream.getReader();\n\n        return makeResource(reader, () => {\n          streamController.close();\n          reader.releaseLock();\n        });\n      },\n      error: (reason: unknown) => {\n        originalController.error(reason);\n\n        clear();\n      },\n    };\n    function clear() {\n      Object.assign(streamController, {\n        closed: true,\n        close: () => {\n          // noop\n        },\n        enqueue: () => {\n          // noop\n        },\n        getReaderResource: null,\n        error: () => {\n          // noop\n        },\n      });\n    }\n\n    return streamController;\n  }\n\n  /**\n   * Gets or creates a stream controller\n   */\n  function getOrCreate(chunkId: ChunkIndex) {\n    let c = controllerMap.get(chunkId);\n    if (!c) {\n      c = createStreamController();\n      controllerMap.set(chunkId, c);\n    }\n    return c;\n  }\n\n  /**\n   * Cancels all pending controllers and rejects deferred promises\n   */\n  function cancelAll(reason: unknown) {\n    for (const controller of controllerMap.values()) {\n      controller.error(reason);\n    }\n  }\n\n  return {\n    getOrCreate,\n    cancelAll,\n  };\n}\n\n/**\n * JSON Lines stream consumer\n * @see https://jsonlines.org/\n */\nexport async function jsonlStreamConsumer<THead>(opts: {\n  from: NodeJSReadableStreamEsque | WebReadableStreamEsque;\n  deserialize?: Deserialize;\n  onError?: ConsumerOnError;\n  formatError?: (opts: { error: unknown }) => Error;\n  /**\n   * This `AbortController` will be triggered when there are no more listeners to the stream.\n   */\n  abortController: AbortController;\n}) {\n  const { deserialize = (v) => v } = opts;\n\n  let source = createConsumerStream<Head>(opts.from);\n  if (deserialize) {\n    source = source.pipeThrough(\n      new TransformStream({\n        transform(chunk, controller) {\n          controller.enqueue(deserialize(chunk));\n        },\n      }),\n    );\n  }\n  let headDeferred: null | Deferred<THead> = createDeferred();\n\n  const streamManager = createStreamsManager(opts.abortController);\n\n  function decodeChunkDefinition(value: ChunkDefinition) {\n    const [_path, type, chunkId] = value;\n\n    const controller = streamManager.getOrCreate(chunkId);\n\n    switch (type) {\n      case CHUNK_VALUE_TYPE_PROMISE: {\n        return run(async () => {\n          using reader = controller.getReaderResource();\n\n          const { value } = await reader.read();\n          const [_chunkId, status, data] = value as PromiseChunk;\n          switch (status) {\n            case PROMISE_STATUS_FULFILLED:\n              return decode(data);\n            case PROMISE_STATUS_REJECTED:\n              throw opts.formatError?.({ error: data }) ?? new AsyncError(data);\n          }\n        });\n      }\n      case CHUNK_VALUE_TYPE_ASYNC_ITERABLE: {\n        return run(async function* () {\n          using reader = controller.getReaderResource();\n\n          while (true) {\n            const { value } = await reader.read();\n\n            const [_chunkId, status, data] = value as IterableChunk;\n\n            switch (status) {\n              case ASYNC_ITERABLE_STATUS_YIELD:\n                yield decode(data);\n                break;\n              case ASYNC_ITERABLE_STATUS_RETURN:\n                return decode(data);\n              case ASYNC_ITERABLE_STATUS_ERROR:\n                throw (\n                  opts.formatError?.({ error: data }) ?? new AsyncError(data)\n                );\n            }\n          }\n        });\n      }\n    }\n  }\n\n  function decode(value: EncodedValue): unknown {\n    const [[data], ...asyncProps] = value;\n\n    for (const value of asyncProps) {\n      const [key] = value;\n      const decoded = decodeChunkDefinition(value);\n\n      if (key === null) {\n        return decoded;\n      }\n\n      (data as any)[key] = decoded;\n    }\n    return data;\n  }\n\n  const closeOrAbort = (reason?: unknown) => {\n    headDeferred?.reject(reason);\n    streamManager.cancelAll(reason);\n  };\n\n  source\n    .pipeTo(\n      new WritableStream({\n        write(chunkOrHead) {\n          if (headDeferred) {\n            const head = chunkOrHead as Record<number | string, unknown>;\n\n            for (const [key, value] of Object.entries(chunkOrHead)) {\n              const parsed = decode(value as any);\n              head[key] = parsed;\n            }\n            headDeferred.resolve(head as THead);\n            headDeferred = null;\n\n            return;\n          }\n          const chunk = chunkOrHead as ChunkData;\n          const [idx] = chunk;\n\n          const controller = streamManager.getOrCreate(idx);\n          controller.enqueue(chunk);\n        },\n        close: closeOrAbort,\n        abort: closeOrAbort,\n      }),\n    )\n    .catch((error) => {\n      opts.onError?.({ error });\n      closeOrAbort(error);\n    });\n\n  return [await headDeferred.promise] as const;\n}\n","var OverloadYield = require(\"./OverloadYield.js\");\nfunction _asyncGeneratorDelegate(t) {\n  var e = {},\n    n = !1;\n  function pump(e, r) {\n    return n = !0, r = new Promise(function (n) {\n      n(t[e](r));\n    }), {\n      done: !1,\n      value: new OverloadYield(r, 1)\n    };\n  }\n  return e[\"undefined\" != typeof Symbol && Symbol.iterator || \"@@iterator\"] = function () {\n    return this;\n  }, e.next = function (t) {\n    return n ? (n = !1, t) : pump(\"next\", t);\n  }, \"function\" == typeof t[\"throw\"] && (e[\"throw\"] = function (t) {\n    if (n) throw n = !1, t;\n    return pump(\"throw\", t);\n  }), \"function\" == typeof t[\"return\"] && (e[\"return\"] = function (t) {\n    return n ? (n = !1, t) : pump(\"return\", t);\n  }), e;\n}\nmodule.exports = _asyncGeneratorDelegate, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import { Unpromise } from '../../vendor/unpromise';\nimport { getTRPCErrorFromUnknown } from '../error/TRPCError';\nimport { isAbortError } from '../http/abortError';\nimport type { MaybePromise } from '../types';\nimport { emptyObject, identity, run } from '../utils';\nimport type { EventSourceLike } from './sse.types';\nimport type { inferTrackedOutput } from './tracked';\nimport { isTrackedEnvelope } from './tracked';\nimport { takeWithGrace } from './utils/asyncIterable';\nimport { makeAsyncResource } from './utils/disposable';\nimport { readableStreamFrom } from './utils/readableStreamFrom';\nimport {\n  disposablePromiseTimerResult,\n  timerResource,\n} from './utils/timerResource';\nimport { PING_SYM, withPing } from './utils/withPing';\n\ntype Serialize = (value: any) => any;\ntype Deserialize = (value: any) => any;\n\n/**\n * @internal\n */\nexport interface SSEPingOptions {\n  /**\n   * Enable ping comments sent from the server\n   * @default false\n   */\n  enabled: boolean;\n  /**\n   * Interval in milliseconds\n   * @default 1000\n   */\n  intervalMs?: number;\n}\n\nexport interface SSEClientOptions {\n  /**\n   * Timeout and reconnect after inactivity in milliseconds\n   * @default undefined\n   */\n  reconnectAfterInactivityMs?: number;\n}\n\nexport interface SSEStreamProducerOptions<TValue = unknown> {\n  serialize?: Serialize;\n  data: AsyncIterable<TValue>;\n\n  maxDepth?: number;\n  ping?: SSEPingOptions;\n  /**\n   * Maximum duration in milliseconds for the request before ending the stream\n   * @default undefined\n   */\n  maxDurationMs?: number;\n  /**\n   * End the request immediately after data is sent\n   * Only useful for serverless runtimes that do not support streaming responses\n   * @default false\n   */\n  emitAndEndImmediately?: boolean;\n  formatError?: (opts: { error: unknown }) => unknown;\n  /**\n   * Client-specific options - these will be sent to the client as part of the first message\n   * @default {}\n   */\n  client?: SSEClientOptions;\n}\n\nconst PING_EVENT = 'ping';\nconst SERIALIZED_ERROR_EVENT = 'serialized-error';\nconst CONNECTED_EVENT = 'connected';\nconst RETURN_EVENT = 'return';\n\ninterface SSEvent {\n  id?: string;\n  data: unknown;\n  comment?: string;\n  event?: string;\n}\n/**\n *\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n */\nexport function sseStreamProducer<TValue = unknown>(\n  opts: SSEStreamProducerOptions<TValue>,\n) {\n  const { serialize = identity } = opts;\n\n  const ping: Required<SSEPingOptions> = {\n    enabled: opts.ping?.enabled ?? false,\n    intervalMs: opts.ping?.intervalMs ?? 1000,\n  };\n  const client: SSEClientOptions = opts.client ?? {};\n\n  if (\n    ping.enabled &&\n    client.reconnectAfterInactivityMs &&\n    ping.intervalMs > client.reconnectAfterInactivityMs\n  ) {\n    throw new Error(\n      `Ping interval must be less than client reconnect interval to prevent unnecessary reconnection - ping.intervalMs: ${ping.intervalMs} client.reconnectAfterInactivityMs: ${client.reconnectAfterInactivityMs}`,\n    );\n  }\n\n  async function* generator(): AsyncIterable<SSEvent, void> {\n    yield {\n      event: CONNECTED_EVENT,\n      data: JSON.stringify(client),\n    };\n\n    type TIteratorValue = Awaited<TValue> | typeof PING_SYM;\n\n    let iterable: AsyncIterable<TValue | typeof PING_SYM> = opts.data;\n\n    if (opts.emitAndEndImmediately) {\n      iterable = takeWithGrace(iterable, {\n        count: 1,\n        gracePeriodMs: 1,\n      });\n    }\n\n    if (ping.enabled && ping.intervalMs !== Infinity && ping.intervalMs > 0) {\n      iterable = withPing(iterable, ping.intervalMs);\n    }\n\n    // We need those declarations outside the loop for garbage collection reasons. If they were\n    // declared inside, they would not be freed until the next value is present.\n    let value: null | TIteratorValue;\n    let chunk: null | SSEvent;\n\n    for await (value of iterable) {\n      if (value === PING_SYM) {\n        yield { event: PING_EVENT, data: '' };\n        continue;\n      }\n\n      chunk = isTrackedEnvelope(value)\n        ? { id: value[0], data: value[1] }\n        : { data: value };\n\n      chunk.data = JSON.stringify(serialize(chunk.data));\n\n      yield chunk;\n\n      // free up references for garbage collection\n      value = null;\n      chunk = null;\n    }\n  }\n\n  async function* generatorWithErrorHandling(): AsyncIterable<SSEvent, void> {\n    try {\n      yield* generator();\n\n      yield {\n        event: RETURN_EVENT,\n        data: '',\n      };\n    } catch (cause) {\n      if (isAbortError(cause)) {\n        // ignore abort errors, send any other errors\n        return;\n      }\n      // `err` must be caused by `opts.data`, `JSON.stringify` or `serialize`.\n      // So, a user error in any case.\n      const error = getTRPCErrorFromUnknown(cause);\n      const data = opts.formatError?.({ error }) ?? null;\n      yield {\n        event: SERIALIZED_ERROR_EVENT,\n        data: JSON.stringify(serialize(data)),\n      };\n    }\n  }\n\n  const stream = readableStreamFrom(generatorWithErrorHandling());\n\n  return stream\n    .pipeThrough(\n      new TransformStream({\n        transform(chunk, controller: TransformStreamDefaultController<string>) {\n          if ('event' in chunk) {\n            controller.enqueue(`event: ${chunk.event}\\n`);\n          }\n          if ('data' in chunk) {\n            controller.enqueue(`data: ${chunk.data}\\n`);\n          }\n          if ('id' in chunk) {\n            controller.enqueue(`id: ${chunk.id}\\n`);\n          }\n          if ('comment' in chunk) {\n            controller.enqueue(`: ${chunk.comment}\\n`);\n          }\n          controller.enqueue('\\n\\n');\n        },\n      }),\n    )\n    .pipeThrough(new TextEncoderStream());\n}\n\ninterface ConsumerStreamResultBase<TConfig extends ConsumerConfig> {\n  eventSource: InstanceType<TConfig['EventSource']> | null;\n}\n\ninterface ConsumerStreamResultData<TConfig extends ConsumerConfig>\n  extends ConsumerStreamResultBase<TConfig> {\n  type: 'data';\n  data: inferTrackedOutput<TConfig['data']>;\n}\n\ninterface ConsumerStreamResultError<TConfig extends ConsumerConfig>\n  extends ConsumerStreamResultBase<TConfig> {\n  type: 'serialized-error';\n  error: TConfig['error'];\n}\n\ninterface ConsumerStreamResultConnecting<TConfig extends ConsumerConfig>\n  extends ConsumerStreamResultBase<TConfig> {\n  type: 'connecting';\n  event: EventSourceLike.EventOf<TConfig['EventSource']> | null;\n}\ninterface ConsumerStreamResultTimeout<TConfig extends ConsumerConfig>\n  extends ConsumerStreamResultBase<TConfig> {\n  type: 'timeout';\n  ms: number;\n}\ninterface ConsumerStreamResultPing<TConfig extends ConsumerConfig>\n  extends ConsumerStreamResultBase<TConfig> {\n  type: 'ping';\n}\n\ninterface ConsumerStreamResultConnected<TConfig extends ConsumerConfig>\n  extends ConsumerStreamResultBase<TConfig> {\n  type: 'connected';\n  options: SSEClientOptions;\n}\n\ntype ConsumerStreamResult<TConfig extends ConsumerConfig> =\n  | ConsumerStreamResultData<TConfig>\n  | ConsumerStreamResultError<TConfig>\n  | ConsumerStreamResultConnecting<TConfig>\n  | ConsumerStreamResultTimeout<TConfig>\n  | ConsumerStreamResultPing<TConfig>\n  | ConsumerStreamResultConnected<TConfig>;\n\nexport interface SSEStreamConsumerOptions<TConfig extends ConsumerConfig> {\n  url: () => MaybePromise<string>;\n  init: () =>\n    | MaybePromise<EventSourceLike.InitDictOf<TConfig['EventSource']>>\n    | undefined;\n  signal: AbortSignal;\n  deserialize?: Deserialize;\n  EventSource: TConfig['EventSource'];\n}\n\ninterface ConsumerConfig {\n  data: unknown;\n  error: unknown;\n  EventSource: EventSourceLike.AnyConstructor;\n}\n\nasync function withTimeout<T>(opts: {\n  promise: Promise<T>;\n  timeoutMs: number;\n  onTimeout: () => Promise<NoInfer<T>>;\n}): Promise<T> {\n  using timeoutPromise = timerResource(opts.timeoutMs);\n  const res = await Unpromise.race([opts.promise, timeoutPromise.start()]);\n\n  if (res === disposablePromiseTimerResult) {\n    return await opts.onTimeout();\n  }\n  return res;\n}\n\n/**\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n */\nexport function sseStreamConsumer<TConfig extends ConsumerConfig>(\n  opts: SSEStreamConsumerOptions<TConfig>,\n): AsyncIterable<ConsumerStreamResult<TConfig>> {\n  const { deserialize = (v) => v } = opts;\n\n  let clientOptions: SSEClientOptions = emptyObject();\n\n  const signal = opts.signal;\n\n  let _es: InstanceType<TConfig['EventSource']> | null = null;\n\n  const createStream = () =>\n    new ReadableStream<ConsumerStreamResult<TConfig>>({\n      async start(controller) {\n        const [url, init] = await Promise.all([opts.url(), opts.init()]);\n        const eventSource = (_es = new opts.EventSource(\n          url,\n          init,\n        ) as InstanceType<TConfig['EventSource']>);\n\n        controller.enqueue({\n          type: 'connecting',\n          eventSource: _es,\n          event: null,\n        });\n\n        eventSource.addEventListener(CONNECTED_EVENT, (_msg) => {\n          const msg = _msg as EventSourceLike.MessageEvent;\n\n          const options: SSEClientOptions = JSON.parse(msg.data);\n\n          clientOptions = options;\n          controller.enqueue({\n            type: 'connected',\n            options,\n            eventSource,\n          });\n        });\n\n        eventSource.addEventListener(SERIALIZED_ERROR_EVENT, (_msg) => {\n          const msg = _msg as EventSourceLike.MessageEvent;\n\n          controller.enqueue({\n            type: 'serialized-error',\n            error: deserialize(JSON.parse(msg.data)),\n            eventSource,\n          });\n        });\n        eventSource.addEventListener(PING_EVENT, () => {\n          controller.enqueue({\n            type: 'ping',\n            eventSource,\n          });\n        });\n        eventSource.addEventListener(RETURN_EVENT, () => {\n          eventSource.close();\n          controller.close();\n          _es = null;\n        });\n        eventSource.addEventListener('error', (event) => {\n          if (eventSource.readyState === eventSource.CLOSED) {\n            controller.error(event);\n          } else {\n            controller.enqueue({\n              type: 'connecting',\n              eventSource,\n              event,\n            });\n          }\n        });\n        eventSource.addEventListener('message', (_msg) => {\n          const msg = _msg as EventSourceLike.MessageEvent;\n\n          const chunk = deserialize(JSON.parse(msg.data));\n\n          const def: SSEvent = {\n            data: chunk,\n          };\n          if (msg.lastEventId) {\n            def.id = msg.lastEventId;\n          }\n          controller.enqueue({\n            type: 'data',\n            data: def as inferTrackedOutput<TConfig['data']>,\n            eventSource,\n          });\n        });\n\n        const onAbort = () => {\n          try {\n            eventSource.close();\n            controller.close();\n          } catch {\n            // ignore errors in case the controller is already closed\n          }\n        };\n        if (signal.aborted) {\n          onAbort();\n        } else {\n          signal.addEventListener('abort', onAbort);\n        }\n      },\n      cancel() {\n        _es?.close();\n      },\n    });\n\n  const getStreamResource = () => {\n    let stream = createStream();\n    let reader = stream.getReader();\n\n    async function dispose() {\n      await reader.cancel();\n      _es = null;\n    }\n\n    return makeAsyncResource(\n      {\n        read() {\n          return reader.read();\n        },\n        async recreate() {\n          await dispose();\n\n          stream = createStream();\n          reader = stream.getReader();\n        },\n      },\n      dispose,\n    );\n  };\n\n  return run(async function* () {\n    await using stream = getStreamResource();\n\n    while (true) {\n      let promise = stream.read();\n\n      const timeoutMs = clientOptions.reconnectAfterInactivityMs;\n      if (timeoutMs) {\n        promise = withTimeout({\n          promise,\n          timeoutMs,\n          onTimeout: async () => {\n            const res: Awaited<typeof promise> = {\n              value: {\n                type: 'timeout',\n                ms: timeoutMs,\n                eventSource: _es,\n              },\n              done: false,\n            };\n            // Close and release old reader\n            await stream.recreate();\n\n            return res;\n          },\n        });\n      }\n\n      const result = await promise;\n\n      if (result.done) {\n        return result.value;\n      }\n      yield result.value;\n    }\n  });\n}\n\nexport const sseHeaders = {\n  'Content-Type': 'text/event-stream',\n  'Cache-Control': 'no-cache, no-transform',\n  'X-Accel-Buffering': 'no',\n  Connection: 'keep-alive',\n} as const;\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport {\n  isObservable,\n  observableToAsyncIterable,\n} from '../../observable/observable';\nimport { getErrorShape } from '../error/getErrorShape';\nimport { getTRPCErrorFromUnknown, TRPCError } from '../error/TRPCError';\nimport type { ProcedureType } from '../procedure';\nimport {\n  type AnyRouter,\n  type inferRouterContext,\n  type inferRouterError,\n} from '../router';\nimport type { TRPCResponse } from '../rpc';\nimport { isPromise, jsonlStreamProducer } from '../stream/jsonl';\nimport { sseHeaders, sseStreamProducer } from '../stream/sse';\nimport { transformTRPCResponse } from '../transformer';\nimport {\n  abortSignalsAnyPonyfill,\n  isAsyncIterable,\n  isObject,\n  run,\n} from '../utils';\nimport { getRequestInfo } from './contentType';\nimport { getHTTPStatusCode } from './getHTTPStatusCode';\nimport type {\n  HTTPBaseHandlerOptions,\n  ResolveHTTPRequestOptionsContextFn,\n  TRPCRequestInfo,\n} from './types';\n\nfunction errorToAsyncIterable(err: TRPCError): AsyncIterable<never> {\n  return run(async function* () {\n    throw err;\n  });\n}\ntype HTTPMethods =\n  | 'GET'\n  | 'POST'\n  | 'HEAD'\n  | 'OPTIONS'\n  | 'PUT'\n  | 'DELETE'\n  | 'PATCH';\n\nfunction combinedAbortController(signal: AbortSignal) {\n  const controller = new AbortController();\n  const combinedSignal = abortSignalsAnyPonyfill([signal, controller.signal]);\n  return {\n    signal: combinedSignal,\n    controller,\n  };\n}\n\nconst TYPE_ACCEPTED_METHOD_MAP: Record<ProcedureType, HTTPMethods[]> = {\n  mutation: ['POST'],\n  query: ['GET'],\n  subscription: ['GET'],\n};\nconst TYPE_ACCEPTED_METHOD_MAP_WITH_METHOD_OVERRIDE: Record<\n  ProcedureType,\n  HTTPMethods[]\n> = {\n  // never allow GET to do a mutation\n  mutation: ['POST'],\n  query: ['GET', 'POST'],\n  subscription: ['GET', 'POST'],\n};\n\ninterface ResolveHTTPRequestOptions<TRouter extends AnyRouter>\n  extends HTTPBaseHandlerOptions<TRouter, Request> {\n  createContext: ResolveHTTPRequestOptionsContextFn<TRouter>;\n  req: Request;\n  path: string;\n  /**\n   * If the request had an issue before reaching the handler\n   */\n  error: TRPCError | null;\n}\n\nfunction initResponse<TRouter extends AnyRouter, TRequest>(initOpts: {\n  ctx: inferRouterContext<TRouter> | undefined;\n  info: TRPCRequestInfo | undefined;\n  responseMeta?: HTTPBaseHandlerOptions<TRouter, TRequest>['responseMeta'];\n  untransformedJSON:\n    | TRPCResponse<unknown, inferRouterError<TRouter>>\n    | TRPCResponse<unknown, inferRouterError<TRouter>>[]\n    | null;\n  errors: TRPCError[];\n  headers: Headers;\n}) {\n  const {\n    ctx,\n    info,\n    responseMeta,\n    untransformedJSON,\n    errors = [],\n    headers,\n  } = initOpts;\n\n  let status = untransformedJSON ? getHTTPStatusCode(untransformedJSON) : 200;\n\n  const eagerGeneration = !untransformedJSON;\n  const data = eagerGeneration\n    ? []\n    : Array.isArray(untransformedJSON)\n      ? untransformedJSON\n      : [untransformedJSON];\n\n  const meta =\n    responseMeta?.({\n      ctx,\n      info,\n      paths: info?.calls.map((call) => call.path),\n      data,\n      errors,\n      eagerGeneration,\n      type:\n        info?.calls.find((call) => call.procedure?._def.type)?.procedure?._def\n          .type ?? 'unknown',\n    }) ?? {};\n\n  if (meta.headers) {\n    if (meta.headers instanceof Headers) {\n      for (const [key, value] of meta.headers.entries()) {\n        headers.append(key, value);\n      }\n    } else {\n      /**\n       * @deprecated, delete in v12\n       */\n      for (const [key, value] of Object.entries(meta.headers)) {\n        if (Array.isArray(value)) {\n          for (const v of value) {\n            headers.append(key, v);\n          }\n        } else if (typeof value === 'string') {\n          headers.set(key, value);\n        }\n      }\n    }\n  }\n  if (meta.status) {\n    status = meta.status;\n  }\n\n  return {\n    status,\n  };\n}\n\nfunction caughtErrorToData<TRouter extends AnyRouter>(\n  cause: unknown,\n  errorOpts: {\n    opts: Pick<\n      ResolveHTTPRequestOptions<TRouter>,\n      'onError' | 'req' | 'router'\n    >;\n    ctx: inferRouterContext<TRouter> | undefined;\n    type: ProcedureType | 'unknown';\n    path?: string;\n    input?: unknown;\n  },\n) {\n  const { router, req, onError } = errorOpts.opts;\n  const error = getTRPCErrorFromUnknown(cause);\n  onError?.({\n    error,\n    path: errorOpts.path,\n    input: errorOpts.input,\n    ctx: errorOpts.ctx,\n    type: errorOpts.type,\n    req,\n  });\n  const untransformedJSON = {\n    error: getErrorShape({\n      config: router._def._config,\n      error,\n      type: errorOpts.type,\n      path: errorOpts.path,\n      input: errorOpts.input,\n      ctx: errorOpts.ctx,\n    }),\n  };\n  const transformedJSON = transformTRPCResponse(\n    router._def._config,\n    untransformedJSON,\n  );\n  const body = JSON.stringify(transformedJSON);\n  return {\n    error,\n    untransformedJSON,\n    body,\n  };\n}\n\n/**\n * Check if a value is a stream-like object\n * - if it's an async iterable\n * - if it's an object with async iterables or promises\n */\nfunction isDataStream(v: unknown) {\n  if (!isObject(v)) {\n    return false;\n  }\n\n  if (isAsyncIterable(v)) {\n    return true;\n  }\n\n  return (\n    Object.values(v).some(isPromise) || Object.values(v).some(isAsyncIterable)\n  );\n}\n\ntype ResultTuple<T> = [undefined, T] | [TRPCError, undefined];\n\nexport async function resolveResponse<TRouter extends AnyRouter>(\n  opts: ResolveHTTPRequestOptions<TRouter>,\n): Promise<Response> {\n  const { router, req } = opts;\n  const headers = new Headers([['vary', 'trpc-accept']]);\n  const config = router._def._config;\n\n  const url = new URL(req.url);\n\n  if (req.method === 'HEAD') {\n    // can be used for lambda warmup\n    return new Response(null, {\n      status: 204,\n    });\n  }\n\n  const allowBatching = opts.allowBatching ?? opts.batching?.enabled ?? true;\n  const allowMethodOverride =\n    (opts.allowMethodOverride ?? false) && req.method === 'POST';\n\n  type $Context = inferRouterContext<TRouter>;\n\n  const infoTuple: ResultTuple<TRPCRequestInfo> = await run(async () => {\n    try {\n      return [\n        undefined,\n        await getRequestInfo({\n          req,\n          path: decodeURIComponent(opts.path),\n          router,\n          searchParams: url.searchParams,\n          headers: opts.req.headers,\n          url,\n        }),\n      ];\n    } catch (cause) {\n      return [getTRPCErrorFromUnknown(cause), undefined];\n    }\n  });\n\n  interface ContextManager {\n    valueOrUndefined: () => $Context | undefined;\n    value: () => $Context;\n    create: (info: TRPCRequestInfo) => Promise<void>;\n  }\n  const ctxManager: ContextManager = run(() => {\n    let result: ResultTuple<$Context> | undefined = undefined;\n    return {\n      valueOrUndefined: () => {\n        if (!result) {\n          return undefined;\n        }\n        return result[1];\n      },\n      value: () => {\n        const [err, ctx] = result!;\n        if (err) {\n          throw err;\n        }\n        return ctx;\n      },\n      create: async (info) => {\n        if (result) {\n          throw new Error(\n            'This should only be called once - report a bug in tRPC',\n          );\n        }\n        try {\n          const ctx = await opts.createContext({\n            info,\n          });\n          result = [undefined, ctx];\n        } catch (cause) {\n          result = [getTRPCErrorFromUnknown(cause), undefined];\n        }\n      },\n    };\n  });\n\n  const methodMapper = allowMethodOverride\n    ? TYPE_ACCEPTED_METHOD_MAP_WITH_METHOD_OVERRIDE\n    : TYPE_ACCEPTED_METHOD_MAP;\n\n  /**\n   * @deprecated\n   */\n  const isStreamCall = req.headers.get('trpc-accept') === 'application/jsonl';\n\n  const experimentalSSE = config.sse?.enabled ?? true;\n  try {\n    const [infoError, info] = infoTuple;\n    if (infoError) {\n      throw infoError;\n    }\n    if (info.isBatchCall && !allowBatching) {\n      throw new TRPCError({\n        code: 'BAD_REQUEST',\n        message: `Batching is not enabled on the server`,\n      });\n    }\n    /* istanbul ignore if -- @preserve */\n    if (isStreamCall && !info.isBatchCall) {\n      throw new TRPCError({\n        message: `Streaming requests must be batched (you can do a batch of 1)`,\n        code: 'BAD_REQUEST',\n      });\n    }\n    await ctxManager.create(info);\n\n    interface RPCResultOk {\n      data: unknown;\n    }\n    type RPCResult = ResultTuple<RPCResultOk>;\n    const rpcCalls = info.calls.map(async (call): Promise<RPCResult> => {\n      const proc = call.procedure;\n      const combinedAbort = combinedAbortController(opts.req.signal);\n      try {\n        if (opts.error) {\n          throw opts.error;\n        }\n\n        if (!proc) {\n          throw new TRPCError({\n            code: 'NOT_FOUND',\n            message: `No procedure found on path \"${call.path}\"`,\n          });\n        }\n\n        if (!methodMapper[proc._def.type].includes(req.method as HTTPMethods)) {\n          throw new TRPCError({\n            code: 'METHOD_NOT_SUPPORTED',\n            message: `Unsupported ${req.method}-request to ${proc._def.type} procedure at path \"${call.path}\"`,\n          });\n        }\n\n        if (proc._def.type === 'subscription') {\n          /* istanbul ignore if -- @preserve */\n          if (info.isBatchCall) {\n            throw new TRPCError({\n              code: 'BAD_REQUEST',\n              message: `Cannot batch subscription calls`,\n            });\n          }\n\n          if (config.sse?.maxDurationMs) {\n            function cleanup() {\n              clearTimeout(timer);\n              combinedAbort.signal.removeEventListener('abort', cleanup);\n\n              combinedAbort.controller.abort();\n            }\n            const timer = setTimeout(cleanup, config.sse.maxDurationMs);\n            combinedAbort.signal.addEventListener('abort', cleanup);\n          }\n        }\n        const data: unknown = await proc({\n          path: call.path,\n          getRawInput: call.getRawInput,\n          ctx: ctxManager.value(),\n          type: proc._def.type,\n          signal: combinedAbort.signal,\n        });\n        return [undefined, { data }];\n      } catch (cause) {\n        const error = getTRPCErrorFromUnknown(cause);\n        const input = call.result();\n\n        opts.onError?.({\n          error,\n          path: call.path,\n          input,\n          ctx: ctxManager.valueOrUndefined(),\n          type: call.procedure?._def.type ?? 'unknown',\n          req: opts.req,\n        });\n\n        return [error, undefined];\n      }\n    });\n\n    // ----------- response handlers -----------\n    if (!info.isBatchCall) {\n      const [call] = info.calls;\n      const [error, result] = await rpcCalls[0]!;\n\n      switch (info.type) {\n        case 'unknown':\n        case 'mutation':\n        case 'query': {\n          // httpLink\n          headers.set('content-type', 'application/json');\n\n          if (isDataStream(result?.data)) {\n            throw new TRPCError({\n              code: 'UNSUPPORTED_MEDIA_TYPE',\n              message:\n                'Cannot use stream-like response in non-streaming request - use httpBatchStreamLink',\n            });\n          }\n          const res: TRPCResponse<unknown, inferRouterError<TRouter>> = error\n            ? {\n                error: getErrorShape({\n                  config,\n                  ctx: ctxManager.valueOrUndefined(),\n                  error,\n                  input: call!.result(),\n                  path: call!.path,\n                  type: info.type,\n                }),\n              }\n            : { result: { data: result.data } };\n\n          const headResponse = initResponse({\n            ctx: ctxManager.valueOrUndefined(),\n            info,\n            responseMeta: opts.responseMeta,\n            errors: error ? [error] : [],\n            headers,\n            untransformedJSON: [res],\n          });\n          return new Response(\n            JSON.stringify(transformTRPCResponse(config, res)),\n            {\n              status: headResponse.status,\n              headers,\n            },\n          );\n        }\n        case 'subscription': {\n          // httpSubscriptionLink\n\n          const iterable: AsyncIterable<unknown> = run(() => {\n            if (error) {\n              return errorToAsyncIterable(error);\n            }\n            if (!experimentalSSE) {\n              return errorToAsyncIterable(\n                new TRPCError({\n                  code: 'METHOD_NOT_SUPPORTED',\n                  message: 'Missing experimental flag \"sseSubscriptions\"',\n                }),\n              );\n            }\n\n            if (!isObservable(result.data) && !isAsyncIterable(result.data)) {\n              return errorToAsyncIterable(\n                new TRPCError({\n                  message: `Subscription ${\n                    call!.path\n                  } did not return an observable or a AsyncGenerator`,\n                  code: 'INTERNAL_SERVER_ERROR',\n                }),\n              );\n            }\n            const dataAsIterable = isObservable(result.data)\n              ? observableToAsyncIterable(result.data, opts.req.signal)\n              : result.data;\n            return dataAsIterable;\n          });\n\n          const stream = sseStreamProducer({\n            ...config.sse,\n            data: iterable,\n            serialize: (v) => config.transformer.output.serialize(v),\n            formatError(errorOpts) {\n              const error = getTRPCErrorFromUnknown(errorOpts.error);\n              const input = call?.result();\n              const path = call?.path;\n              const type = call?.procedure?._def.type ?? 'unknown';\n\n              opts.onError?.({\n                error,\n                path,\n                input,\n                ctx: ctxManager.valueOrUndefined(),\n                req: opts.req,\n                type,\n              });\n\n              const shape = getErrorShape({\n                config,\n                ctx: ctxManager.valueOrUndefined(),\n                error,\n                input,\n                path,\n                type,\n              });\n\n              return shape;\n            },\n          });\n          for (const [key, value] of Object.entries(sseHeaders)) {\n            headers.set(key, value);\n          }\n\n          const headResponse = initResponse({\n            ctx: ctxManager.valueOrUndefined(),\n            info,\n            responseMeta: opts.responseMeta,\n            errors: [],\n            headers,\n            untransformedJSON: null,\n          });\n\n          return new Response(stream, {\n            headers,\n            status: headResponse.status,\n          });\n        }\n      }\n    }\n\n    // batch response handlers\n    if (info.accept === 'application/jsonl') {\n      // httpBatchStreamLink\n      headers.set('content-type', 'application/json');\n      headers.set('transfer-encoding', 'chunked');\n      const headResponse = initResponse({\n        ctx: ctxManager.valueOrUndefined(),\n        info,\n        responseMeta: opts.responseMeta,\n        errors: [],\n        headers,\n        untransformedJSON: null,\n      });\n      const stream = jsonlStreamProducer({\n        ...config.jsonl,\n        /**\n         * Example structure for `maxDepth: 4`:\n         * {\n         *   // 1\n         *   0: {\n         *     // 2\n         *     result: {\n         *       // 3\n         *       data: // 4\n         *     }\n         *   }\n         * }\n         */\n        maxDepth: Infinity,\n        data: rpcCalls.map(async (res) => {\n          const [error, result] = await res;\n\n          const call = info.calls[0];\n\n          if (error) {\n            return {\n              error: getErrorShape({\n                config,\n                ctx: ctxManager.valueOrUndefined(),\n                error,\n                input: call!.result(),\n                path: call!.path,\n                type: call!.procedure?._def.type ?? 'unknown',\n              }),\n            };\n          }\n\n          /**\n           * Not very pretty, but we need to wrap nested data in promises\n           * Our stream producer will only resolve top-level async values or async values that are directly nested in another async value\n           */\n          const iterable = isObservable(result.data)\n            ? observableToAsyncIterable(result.data, opts.req.signal)\n            : Promise.resolve(result.data);\n          return {\n            result: Promise.resolve({\n              data: iterable,\n            }),\n          };\n        }),\n        serialize: (data) => config.transformer.output.serialize(data),\n        onError: (cause) => {\n          opts.onError?.({\n            error: getTRPCErrorFromUnknown(cause),\n            path: undefined,\n            input: undefined,\n            ctx: ctxManager.valueOrUndefined(),\n            req: opts.req,\n            type: info?.type ?? 'unknown',\n          });\n        },\n\n        formatError(errorOpts) {\n          const call = info?.calls[errorOpts.path[0] as any];\n\n          const error = getTRPCErrorFromUnknown(errorOpts.error);\n          const input = call?.result();\n          const path = call?.path;\n          const type = call?.procedure?._def.type ?? 'unknown';\n\n          // no need to call `onError` here as it will be propagated through the stream itself\n\n          const shape = getErrorShape({\n            config,\n            ctx: ctxManager.valueOrUndefined(),\n            error,\n            input,\n            path,\n            type,\n          });\n\n          return shape;\n        },\n      });\n\n      return new Response(stream, {\n        headers,\n        status: headResponse.status,\n      });\n    }\n\n    // httpBatchLink\n    /**\n     * Non-streaming response:\n     * - await all responses in parallel, blocking on the slowest one\n     * - create headers with known response body\n     * - return a complete HTTPResponse\n     */\n    headers.set('content-type', 'application/json');\n    const results: RPCResult[] = (await Promise.all(rpcCalls)).map(\n      (res): RPCResult => {\n        const [error, result] = res;\n        if (error) {\n          return res;\n        }\n\n        if (isDataStream(result.data)) {\n          return [\n            new TRPCError({\n              code: 'UNSUPPORTED_MEDIA_TYPE',\n              message:\n                'Cannot use stream-like response in non-streaming request - use httpBatchStreamLink',\n            }),\n            undefined,\n          ];\n        }\n        return res;\n      },\n    );\n    const resultAsRPCResponse = results.map(\n      (\n        [error, result],\n        index,\n      ): TRPCResponse<unknown, inferRouterError<TRouter>> => {\n        const call = info.calls[index]!;\n        if (error) {\n          return {\n            error: getErrorShape({\n              config,\n              ctx: ctxManager.valueOrUndefined(),\n              error,\n              input: call.result(),\n              path: call.path,\n              type: call.procedure?._def.type ?? 'unknown',\n            }),\n          };\n        }\n        return {\n          result: { data: result.data },\n        };\n      },\n    );\n\n    const errors = results\n      .map(([error]) => error)\n      .filter(Boolean) as TRPCError[];\n\n    const headResponse = initResponse({\n      ctx: ctxManager.valueOrUndefined(),\n      info,\n      responseMeta: opts.responseMeta,\n      untransformedJSON: resultAsRPCResponse,\n      errors,\n      headers,\n    });\n\n    return new Response(\n      JSON.stringify(transformTRPCResponse(config, resultAsRPCResponse)),\n      {\n        status: headResponse.status,\n        headers,\n      },\n    );\n  } catch (cause) {\n    const [_infoError, info] = infoTuple;\n    const ctx = ctxManager.valueOrUndefined();\n    // we get here if\n    // - batching is called when it's not enabled\n    // - `createContext()` throws\n    // - `router._def._config.transformer.output.serialize()` throws\n    // - post body is too large\n    // - input deserialization fails\n    // - `errorFormatter` return value is malformed\n    const { error, untransformedJSON, body } = caughtErrorToData(cause, {\n      opts,\n      ctx: ctxManager.valueOrUndefined(),\n      type: info?.type ?? 'unknown',\n    });\n\n    const headResponse = initResponse({\n      ctx,\n      info,\n      responseMeta: opts.responseMeta,\n      untransformedJSON,\n      errors: [error],\n      headers,\n    });\n\n    return new Response(body, {\n      status: headResponse.status,\n      headers,\n    });\n  }\n}\n"],"names":["defaultFormatter: ErrorFormatter<any, any>","obj1: TType","newObj: TType","parsed: unknown","self: Observable<TValue, TError>","INFINITE_CACHE","fn: unknown","cause: unknown","fn: MiddlewareFunction<\n      TContext,\n      TMeta,\n      object,\n      $ContextOverrides,\n      TInputOut\n    >","str: string","memo: Record<string, unknown>","parse: ParseFn<TInput>","inputMiddleware: AnyMiddlewareFunction","fn: () => TValue","it: T","promise: Promise<TReturn> | null","condition: boolean","transformer: DataTransformerOptions","env","parse: ParseFn<TOutput>","signals: AbortSignal[]","process","__NEXT_MULTI_ZONE_DRAFT_MODE","callback: ProxyCallback","config: RootConfig<AnyRootTypes>","callback: (path: keyof TFaux) => any","inputs: unknown","itemOrItems: TResponse","JSONRPC2_TO_HTTP_CODE: Record<\n  keyof typeof TRPC_ERROR_CODES_BY_KEY,\n  number\n>","transformer: DataTransformer","signal: AbortSignal","unsub: Unsubscribable | null","acc: InputRecord","response:\n    | TRPCResponse<TOutput, inferRouterError<TRouter>>\n    | TRPCResponseMessage<TOutput, inferRouterError<TRouter>>","observable","code: keyof typeof TRPC_ERROR_CODES_BY_KEY","result: T | typeof uncalled","retryableRpcCodes: TRPC_ERROR_CODE_NUMBER[]","code: keyof typeof HTTP_CODE_TO_JSONRPC2","importRouter: () => Promise<\n    | TRouter\n    | {\n        [key: string]: TRouter;\n      }\n  >","_objectWithoutProperties","formDataContentTypeHandler: ContentTypeHandler","input: unknown","error: TRPCError","_typeof","def1: AnyProcedureBuilderDef","def2: Partial<AnyProcedureBuilderDef>","o","initDef: Partial<AnyProcedureBuilderDef>","_def: AnyProcedureBuilderDef","builder: AnyProcedureBuilder","toPrimitive","input: TInput","MINIMAL_MODE","procedures: Record<string, AnyProcedure>","opts: {\n      ref: Lazy<AnyRouter>;\n      path: readonly string[];\n      key: string;\n      aggregate: RouterRecord;\n    }","router","lazy","toPropertyKey","builder","path: readonly string[]","aggregate: RouterRecord","req: Request","handler","r","opts: GetRequestInfoOptions","_def: AnyProcedure['_def']","error: unknown","_def: AnyRouter['_def']","router: BuiltRouter<TRoot, {}>","o: unknown","opts: {\n  config: RootConfig<TRoot>;\n  error: TRPCError;\n  type: ProcedureType | 'unknown';\n  path: string | undefined;\n  input: unknown;\n  ctx: TRoot['ctx'] | undefined;\n}","shape: DefaultErrorShape","index: number","path: string","key","opts: ProcedureCallOptions<unknown> & {\n    router: AnyRouter;\n    allowMethodOverride?: boolean;\n  }","opts: ProcedureCallOptions<unknown>","router: Pick<Router<TRoot, TRecord>, '_def'>","ctx: Context | undefined","arg: Promise<T> | PromiseLike<T> | PromiseExecutor<T>","opts?: ValidateShape<TOptions, RuntimeConfigOptions<TContext, TMeta>>","config: RootConfig<$Root>","isServer: boolean","event: { id: string; data: TData }","promise: Promise<T>","unsubscribe: () => void","value: unknown","data: TData","onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | null","onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | null","onrejected?:\n      | ((reason: any) => TResult | PromiseLike<TResult>)\n      | null","onfinally?: (() => void) | null","promise: PromiseLike<T>","value: T | PromiseLike<T>","values: Iterable<T | PromiseLike<T>>","promises: readonly TPromise[]","promise: TPromise","resolve!: PromiseWithResolvers<T>[\"resolve\"]","reject!: PromiseWithResolvers<T>[\"reject\"]","arr: readonly T[]","member: T","member: unknown","thing: T","dispose: () => void","dispose: () => Promise<void>","ms: number","timer: ReturnType<typeof setTimeout> | null","e","n","OverloadYield","_awaitAsyncGenerator","_wrapAsyncGenerator","t","iterable: AsyncIterable<TYield, TReturn, TNext>","iterable: AsyncIterable<T>","opts: {\n    count: number;\n    gracePeriodMs: number;\n  }","result: null | IteratorResult<T> | typeof disposablePromiseTimerResult","resolve: (value: TValue) => void","reject: (error: unknown) => void","iterable: AsyncIterable<TYield, TReturn>","onResult: (result: ManagedIteratorResult<TYield, TReturn>) => void","state: 'idle' | 'pending' | 'done'","iterables: AsyncIterable<TYield, void, unknown>[]","buffer: Array<\n    [\n      iterator: ManagedIterator<TYield, void>,\n      result: Exclude<\n        ManagedIteratorResult<TYield, void>,\n        { status: 'return' }\n      >,\n    ]\n  >","iterable: AsyncIterable<TYield, void, unknown>","errors: unknown[]","iterable: AsyncIterable<TYield, void>","iterable: AsyncIterable<TValue>","pingIntervalMs: number","result:\n    | null\n    | IteratorResult<TValue>\n    | typeof disposablePromiseTimerResult","_asyncIterator","AsyncFromSyncIterator","path: (string | number)[]","opts: JSONLProducerOptions","callback: (idx: ChunkIndex) => AsyncIterable<ChunkData, void>","iterable","promise: Promise<unknown>","iterable: AsyncIterable<unknown>","newObj: Record<string, unknown>","asyncValues: ChunkDefinition[]","newHead: Head","iterable: AsyncIterable<ChunkData | typeof PING_SYM, void>","data: unknown","source: NodeJSReadableStreamEsque","from: NodeJSReadableStreamEsque | WebReadableStreamEsque","chunk: ChunkData","abortController: AbortController","originalController: ReadableStreamDefaultController<ChunkData>","v: ChunkData","reason: unknown","chunkId: ChunkIndex","opts: {\n  from: NodeJSReadableStreamEsque | WebReadableStreamEsque;\n  deserialize?: Deserialize;\n  onError?: ConsumerOnError;\n  formatError?: (opts: { error: unknown }) => Error;\n  /**\n   * This `AbortController` will be triggered when there are no more listeners to the stream.\n   */\n  abortController: AbortController;\n}","headDeferred: null | Deferred<THead>","value: ChunkDefinition","value","value: EncodedValue","reason?: unknown","_asyncGeneratorDelegate","opts: SSEStreamProducerOptions<TValue>","ping: Required<SSEPingOptions>","client: SSEClientOptions","iterable: AsyncIterable<TValue | typeof PING_SYM>","value: null | TIteratorValue","chunk: null | SSEvent","controller: TransformStreamDefaultController<string>","opts: {\n  promise: Promise<T>;\n  timeoutMs: number;\n  onTimeout: () => Promise<NoInfer<T>>;\n}","opts: SSEStreamConsumerOptions<TConfig>","clientOptions: SSEClientOptions","_es: InstanceType<TConfig['EventSource']> | null","options: SSEClientOptions","def: SSEvent","res: Awaited<typeof promise>","err: TRPCError","TYPE_ACCEPTED_METHOD_MAP: Record<ProcedureType, HTTPMethods[]>","TYPE_ACCEPTED_METHOD_MAP_WITH_METHOD_OVERRIDE: Record<\n  ProcedureType,\n  HTTPMethods[]\n>","initOpts: {\n  ctx: inferRouterContext<TRouter> | undefined;\n  info: TRPCRequestInfo | undefined;\n  responseMeta?: HTTPBaseHandlerOptions<TRouter, TRequest>['responseMeta'];\n  untransformedJSON:\n    | TRPCResponse<unknown, inferRouterError<TRouter>>\n    | TRPCResponse<unknown, inferRouterError<TRouter>>[]\n    | null;\n  errors: TRPCError[];\n  headers: Headers;\n}","errorOpts: {\n    opts: Pick<\n      ResolveHTTPRequestOptions<TRouter>,\n      'onError' | 'req' | 'router'\n    >;\n    ctx: inferRouterContext<TRouter> | undefined;\n    type: ProcedureType | 'unknown';\n    path?: string;\n    input?: unknown;\n  }","v: unknown","opts: ResolveHTTPRequestOptions<TRouter>","infoTuple: ResultTuple<TRPCRequestInfo>","ctxManager: ContextManager","result: ResultTuple<$Context> | undefined","res: TRPCResponse<unknown, inferRouterError<TRouter>>","headResponse","error","results: RPCResult[]"],"mappings":"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","ignoreList":[0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,18,19,20,21,22,24,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66]}